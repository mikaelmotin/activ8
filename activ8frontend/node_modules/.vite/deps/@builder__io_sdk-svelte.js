import "./chunk-X7HCJ7ZS.js";
import {
  HtmlTagHydration,
  SvelteComponentDev,
  action_destroyer,
  add_location,
  append_hydration_dev,
  append_styles,
  assign,
  attr_dev,
  binding_callbacks,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_html_tag,
  claim_space,
  claim_text,
  compute_slots,
  construct_svelte_component_dev,
  create_component,
  create_slot,
  destroy_component,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  ensure_array_like_dev,
  getContext,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_spread_object,
  get_spread_update,
  globals,
  group_outros,
  init,
  insert_hydration_dev,
  is_function,
  listen_dev,
  mount_component,
  noop,
  null_to_empty,
  onDestroy,
  onMount,
  outro_and_destroy_block,
  run_all,
  safe_not_equal,
  setContext,
  set_attributes,
  set_data_dev,
  set_data_maybe_contenteditable_dev,
  set_dynamic_element_data,
  space,
  src_url_equal,
  srcset_url_equal,
  text,
  toggle_class,
  transition_in,
  transition_out,
  update_keyed_each,
  update_slot_base,
  validate_dynamic_element,
  validate_each_keys,
  validate_slots,
  validate_void_dynamic_element
} from "./chunk-J2VQCU4O.js";
import "./chunk-UWR55C7Y.js";
import "./chunk-Y7YSCATX.js";
import "./chunk-2B2CG5KL.js";

// node_modules/@builder.io/sdk-svelte/package/blocks/button/button.svelte
var { Object: Object_1 } = globals;
var file = "node_modules\\@builder.io\\sdk-svelte\\package\\blocks\\button\\button.svelte";
function add_css(target) {
  append_styles(target, "svelte-164dyn4", ".button.svelte-164dyn4{all:unset}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnV0dG9uLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUF5REUsc0JBQVEsQ0FDTixHQUFHLENBQUUsS0FDUCIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJidXR0b24uc3ZlbHRlIl19 */");
}
function create_else_block(ctx) {
  let button;
  let t;
  let button_class_value;
  let setAttrs_action;
  let mounted;
  let dispose;
  let button_levels = [
    {
      class: button_class_value = /** * We have to explicitly provide `class` so that Mitosis knows to merge it with `css`. */
      /*attributes*/
      ctx[0].class + " button"
    },
    /*filterAttrs*/
    ctx[6](
      /*attributes*/
      ctx[0],
      /*isNonEvent*/
      ctx[5]
    )
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block = {
    c: function create() {
      button = element("button");
      t = text(
        /*text*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { class: true });
      var button_nodes = children(button);
      t = claim_text(
        button_nodes,
        /*text*/
        ctx[1]
      );
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(button, button_data);
      toggle_class(button, "svelte-164dyn4", true);
      add_location(button, file, 46, 2, 1227);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, t);
      if (button.autofocus)
        button.focus();
      if (!mounted) {
        dispose = action_destroyer(setAttrs_action = /*setAttrs*/
        ctx[7].call(
          null,
          button,
          /*filterAttrs*/
          ctx[6](
            /*attributes*/
            ctx[0],
            /*isEvent*/
            ctx[4]
          )
        ));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*text*/
      2)
        set_data_maybe_contenteditable_dev(
          t,
          /*text*/
          ctx2[1],
          button_data["contenteditable"]
        );
      set_attributes(button, button_data = get_spread_update(button_levels, [
        dirty & /*attributes*/
        1 && button_class_value !== (button_class_value = /** * We have to explicitly provide `class` so that Mitosis knows to merge it with `css`. */
        /*attributes*/
        ctx2[0].class + " button") && { class: button_class_value },
        dirty & /*attributes*/
        1 && /*filterAttrs*/
        ctx2[6](
          /*attributes*/
          ctx2[0],
          /*isNonEvent*/
          ctx2[5]
        )
      ]));
      if (setAttrs_action && is_function(setAttrs_action.update) && dirty & /*attributes*/
      1)
        setAttrs_action.update.call(
          null,
          /*filterAttrs*/
          ctx2[6](
            /*attributes*/
            ctx2[0],
            /*isEvent*/
            ctx2[4]
          )
        );
      toggle_class(button, "svelte-164dyn4", true);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(46:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let a;
  let t;
  let a_target_value;
  let setAttrs_action;
  let mounted;
  let dispose;
  let a_levels = [
    { role: "button" },
    /*filterAttrs*/
    ctx[6](
      /*attributes*/
      ctx[0],
      /*isNonEvent*/
      ctx[5]
    ),
    { href: (
      /*link*/
      ctx[2]
    ) },
    {
      target: a_target_value = /*openLinkInNewTab*/
      ctx[3] ? "_blank" : void 0
    }
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  const block = {
    c: function create() {
      a = element("a");
      t = text(
        /*text*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      a = claim_element(nodes, "A", { role: true, href: true, target: true });
      var a_nodes = children(a);
      t = claim_text(
        a_nodes,
        /*text*/
        ctx[1]
      );
      a_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(a, a_data);
      toggle_class(a, "svelte-164dyn4", true);
      add_location(a, file, 36, 2, 1008);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, a, anchor);
      append_hydration_dev(a, t);
      if (!mounted) {
        dispose = action_destroyer(setAttrs_action = /*setAttrs*/
        ctx[7].call(
          null,
          a,
          /*filterAttrs*/
          ctx[6](
            /*attributes*/
            ctx[0],
            /*isEvent*/
            ctx[4]
          )
        ));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*text*/
      2)
        set_data_maybe_contenteditable_dev(
          t,
          /*text*/
          ctx2[1],
          a_data["contenteditable"]
        );
      set_attributes(a, a_data = get_spread_update(a_levels, [
        { role: "button" },
        dirty & /*attributes*/
        1 && /*filterAttrs*/
        ctx2[6](
          /*attributes*/
          ctx2[0],
          /*isNonEvent*/
          ctx2[5]
        ),
        dirty & /*link*/
        4 && { href: (
          /*link*/
          ctx2[2]
        ) },
        dirty & /*openLinkInNewTab*/
        8 && a_target_value !== (a_target_value = /*openLinkInNewTab*/
        ctx2[3] ? "_blank" : void 0) && { target: a_target_value }
      ]));
      if (setAttrs_action && is_function(setAttrs_action.update) && dirty & /*attributes*/
      1)
        setAttrs_action.update.call(
          null,
          /*filterAttrs*/
          ctx2[6](
            /*attributes*/
            ctx2[0],
            /*isEvent*/
            ctx2[4]
          )
        );
      toggle_class(a, "svelte-164dyn4", true);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(a);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(36:0) {#if link}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (
      /*link*/
      ctx2[2]
    )
      return create_if_block;
    return create_else_block;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Button", slots, []);
  const isEvent = (attr) => attr.startsWith("on:");
  const isNonEvent = (attr) => !attr.startsWith("on:");
  const filterAttrs = (attrs = {}, filter) => {
    const validAttr = {};
    Object.keys(attrs).forEach((attr) => {
      if (filter(attr)) {
        validAttr[attr] = attrs[attr];
      }
    });
    return validAttr;
  };
  const setAttrs = (node, attrs = {}) => {
    const attrKeys = Object.keys(attrs);
    const setup = (attr) => node.addEventListener(attr.substr(3), attrs[attr]);
    const teardown = (attr) => node.removeEventListener(attr.substr(3), attrs[attr]);
    attrKeys.map(setup);
    return {
      update(attrs2 = {}) {
        const attrKeys2 = Object.keys(attrs2);
        attrKeys2.map(teardown);
        attrKeys2.map(setup);
      },
      destroy() {
        attrKeys.map(teardown);
      }
    };
  };
  let { attributes } = $$props;
  let { text: text2 } = $$props;
  let { link } = $$props;
  let { openLinkInNewTab } = $$props;
  $$self.$$.on_mount.push(function() {
    if (attributes === void 0 && !("attributes" in $$props || $$self.$$.bound[$$self.$$.props["attributes"]])) {
      console.warn("<Button> was created without expected prop 'attributes'");
    }
    if (text2 === void 0 && !("text" in $$props || $$self.$$.bound[$$self.$$.props["text"]])) {
      console.warn("<Button> was created without expected prop 'text'");
    }
    if (link === void 0 && !("link" in $$props || $$self.$$.bound[$$self.$$.props["link"]])) {
      console.warn("<Button> was created without expected prop 'link'");
    }
    if (openLinkInNewTab === void 0 && !("openLinkInNewTab" in $$props || $$self.$$.bound[$$self.$$.props["openLinkInNewTab"]])) {
      console.warn("<Button> was created without expected prop 'openLinkInNewTab'");
    }
  });
  const writable_props = ["attributes", "text", "link", "openLinkInNewTab"];
  Object_1.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<Button> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("attributes" in $$props2)
      $$invalidate(0, attributes = $$props2.attributes);
    if ("text" in $$props2)
      $$invalidate(1, text2 = $$props2.text);
    if ("link" in $$props2)
      $$invalidate(2, link = $$props2.link);
    if ("openLinkInNewTab" in $$props2)
      $$invalidate(3, openLinkInNewTab = $$props2.openLinkInNewTab);
  };
  $$self.$capture_state = () => ({
    isEvent,
    isNonEvent,
    filterAttrs,
    setAttrs,
    attributes,
    text: text2,
    link,
    openLinkInNewTab
  });
  $$self.$inject_state = ($$props2) => {
    if ("attributes" in $$props2)
      $$invalidate(0, attributes = $$props2.attributes);
    if ("text" in $$props2)
      $$invalidate(1, text2 = $$props2.text);
    if ("link" in $$props2)
      $$invalidate(2, link = $$props2.link);
    if ("openLinkInNewTab" in $$props2)
      $$invalidate(3, openLinkInNewTab = $$props2.openLinkInNewTab);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    attributes,
    text2,
    link,
    openLinkInNewTab,
    isEvent,
    isNonEvent,
    filterAttrs,
    setAttrs
  ];
}
var Button = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance,
      create_fragment,
      safe_not_equal,
      {
        attributes: 0,
        text: 1,
        link: 2,
        openLinkInNewTab: 3
      },
      add_css
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Button",
      options,
      id: create_fragment.name
    });
  }
  get attributes() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set attributes(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get text() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get link() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set link(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get openLinkInNewTab() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set openLinkInNewTab(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var button_default = Button;

// node_modules/@builder.io/sdk-svelte/package/context/builder.context.js
var key = Symbol();
var builder_context_default = {
  Builder: {
    content: null,
    context: {},
    state: {},
    setState() {
    },
    apiKey: null,
    apiVersion: void 0,
    registeredComponents: {},
    inheritedStyles: {}
  },
  key
};

// node_modules/@builder.io/sdk-svelte/package/constants/target.js
var TARGET = "svelte";

// node_modules/@builder.io/sdk-svelte/package/functions/is-browser.js
function isBrowser() {
  return typeof window !== "undefined" && typeof document !== "undefined";
}

// node_modules/@builder.io/sdk-svelte/package/functions/is-iframe.js
function isIframe() {
  return isBrowser() && window.self !== window.top;
}

// node_modules/@builder.io/sdk-svelte/package/functions/is-editing.js
function isEditing() {
  return isIframe() && (TARGET === "reactNative" || window.location.search.indexOf("builder.frameEditing=") !== -1);
}

// node_modules/@builder.io/sdk-svelte/package/functions/fast-clone.js
var fastClone = (obj) => JSON.parse(JSON.stringify(obj));

// node_modules/@builder.io/sdk-svelte/package/constants/device-sizes.js
var SIZES = {
  small: {
    min: 320,
    default: 321,
    max: 640
  },
  medium: {
    min: 641,
    default: 642,
    max: 991
  },
  large: {
    min: 990,
    default: 991,
    max: 1200
  }
};
var getMaxWidthQueryForSize = (size, sizeValues = SIZES) => `@media (max-width: ${sizeValues[size].max}px)`;
var getSizesForBreakpoints = ({ small, medium }) => {
  const newSizes = fastClone(SIZES);
  if (!small || !medium) {
    return newSizes;
  }
  const smallMin = Math.floor(small / 2);
  newSizes.small = {
    max: small,
    min: smallMin,
    default: smallMin + 1
  };
  const mediumMin = newSizes.small.max + 1;
  newSizes.medium = {
    max: medium,
    min: mediumMin,
    default: mediumMin + 1
  };
  const largeMin = newSizes.medium.max + 1;
  newSizes.large = {
    max: 2e3,
    min: largeMin,
    default: largeMin + 1
  };
  return newSizes;
};

// node_modules/@builder.io/sdk-svelte/package/functions/evaluate.js
function evaluate({ code, context, state, event, isExpression = true }) {
  if (code === "") {
    console.warn("Skipping evaluation of empty code block.");
    return;
  }
  const builder = {
    isEditing: isEditing(),
    isBrowser: isBrowser(),
    isServer: !isBrowser()
  };
  const useReturn = (
    // we disable this for cases where we definitely don't want a return
    isExpression && !(code.includes(";") || code.includes(" return ") || code.trim().startsWith("return "))
  );
  const useCode = useReturn ? `return (${code});` : code;
  try {
    return new Function("builder", "Builder", "state", "context", "event", useCode)(builder, builder, state, context, event);
  } catch (e) {
    console.warn("Builder custom code error: \n While Evaluating: \n ", useCode, "\n", e);
  }
}

// node_modules/@builder.io/sdk-svelte/package/functions/set.js
var set = (obj, _path, value) => {
  if (Object(obj) !== obj) {
    return obj;
  }
  const path = Array.isArray(_path) ? _path : _path.toString().match(/[^.[\]]+/g);
  path.slice(0, -1).reduce((a, c, i) => Object(a[c]) === a[c] ? a[c] : a[c] = Math.abs(Number(path[i + 1])) >> 0 === +path[i + 1] ? [] : {}, obj)[path[path.length - 1]] = value;
  return obj;
};

// node_modules/@builder.io/sdk-svelte/package/functions/transform-block.js
function transformBlock(block) {
  return block;
}

// node_modules/@builder.io/sdk-svelte/package/functions/get-processed-block.js
var evaluateBindings = ({ block, context, state }) => {
  if (!block.bindings) {
    return block;
  }
  const copy = fastClone(block);
  const copied = {
    ...copy,
    properties: { ...copy.properties },
    actions: { ...copy.actions }
  };
  for (const binding in block.bindings) {
    const expression = block.bindings[binding];
    const value = evaluate({ code: expression, state, context });
    set(copied, binding, value);
  }
  return copied;
};
function getProcessedBlock({ block, context, shouldEvaluateBindings, state }) {
  const transformedBlock = transformBlock(block);
  if (shouldEvaluateBindings) {
    return evaluateBindings({ block: transformedBlock, state, context });
  } else {
    return transformedBlock;
  }
}

// node_modules/@builder.io/sdk-svelte/package/functions/camel-to-kebab-case.js
var camelToKebabCase = (string) => string.replace(/([a-z0-9]|(?=[A-Z]))([A-Z])/g, "$1-$2").toLowerCase();

// node_modules/@builder.io/sdk-svelte/package/helpers/nullable.js
var checkIsDefined = (maybeT) => maybeT !== null && maybeT !== void 0;

// node_modules/@builder.io/sdk-svelte/package/helpers/css.js
var convertStyleMapToCSSArray = (style) => {
  const cssProps = Object.entries(style).map(([key2, value]) => {
    if (typeof value === "string") {
      return `${camelToKebabCase(key2)}: ${value};`;
    } else {
      return void 0;
    }
  });
  return cssProps.filter(checkIsDefined);
};
var convertStyleMapToCSS = (style) => convertStyleMapToCSSArray(style).join("\n");
var createCssClass = ({ mediaQuery, className, styles }) => {
  const cssClass = `.${className} {
    ${convertStyleMapToCSS(styles)}
  }`;
  if (mediaQuery) {
    return `${mediaQuery} {
      ${cssClass}
    }`;
  } else {
    return cssClass;
  }
};

// node_modules/@builder.io/sdk-svelte/package/components/render-inlined-styles.svelte
var file2 = "node_modules\\@builder.io\\sdk-svelte\\package\\components\\render-inlined-styles.svelte";
function create_else_block2(ctx) {
  let previous_tag = (
    /*tag*/
    ctx[1]()
  );
  let svelte_element_anchor;
  validate_dynamic_element(
    /*tag*/
    ctx[1]()
  );
  validate_void_dynamic_element(
    /*tag*/
    ctx[1]()
  );
  let svelte_element = (
    /*tag*/
    ctx[1]() && create_dynamic_element(ctx)
  );
  const block = {
    c: function create() {
      if (svelte_element)
        svelte_element.c();
      svelte_element_anchor = empty();
    },
    l: function claim(nodes) {
      if (svelte_element)
        svelte_element.l(nodes);
      svelte_element_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (svelte_element)
        svelte_element.m(target, anchor);
      insert_hydration_dev(target, svelte_element_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (
        /*tag*/
        ctx2[1]()
      ) {
        if (!previous_tag) {
          svelte_element = create_dynamic_element(ctx2);
          previous_tag = /*tag*/
          ctx2[1]();
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else if (safe_not_equal(
          previous_tag,
          /*tag*/
          ctx2[1]()
        )) {
          svelte_element.d(1);
          validate_dynamic_element(
            /*tag*/
            ctx2[1]()
          );
          validate_void_dynamic_element(
            /*tag*/
            ctx2[1]()
          );
          svelte_element = create_dynamic_element(ctx2);
          previous_tag = /*tag*/
          ctx2[1]();
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else {
          svelte_element.p(ctx2, dirty);
        }
      } else if (previous_tag) {
        svelte_element.d(1);
        svelte_element = null;
        previous_tag = /*tag*/
        ctx2[1]();
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svelte_element_anchor);
      }
      if (svelte_element)
        svelte_element.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block2.name,
    type: "else",
    source: "(17:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block2(ctx) {
  let html_tag;
  let raw_value = (
    /*injectedStyleScript*/
    ctx[2]() + ""
  );
  let html_anchor;
  const block = {
    c: function create() {
      html_tag = new HtmlTagHydration(false);
      html_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      html_tag = claim_html_tag(nodes, false);
      html_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      html_tag.a = html_anchor;
    },
    m: function mount(target, anchor) {
      html_tag.m(raw_value, target, anchor);
      insert_hydration_dev(target, html_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*injectedStyleScript*/
      4 && raw_value !== (raw_value = /*injectedStyleScript*/
      ctx2[2]() + ""))
        html_tag.p(raw_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(html_anchor);
        html_tag.d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: '(15:0) {#if TARGET === \\"svelte\\" || TARGET === \\"qwik\\"}',
    ctx
  });
  return block;
}
function create_dynamic_element(ctx) {
  let svelte_element;
  let t;
  const block = {
    c: function create() {
      svelte_element = element(
        /*tag*/
        ctx[1]()
      );
      t = text(
        /*styles*/
        ctx[0]
      );
      this.h();
    },
    l: function claim(nodes) {
      svelte_element = claim_element(
        nodes,
        /*tag*/
        (ctx[1]() || "null").toUpperCase(),
        {}
      );
      var svelte_element_nodes = children(svelte_element);
      t = claim_text(
        svelte_element_nodes,
        /*styles*/
        ctx[0]
      );
      svelte_element_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(svelte_element, file2, 17, 2, 537);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svelte_element, anchor);
      append_hydration_dev(svelte_element, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*styles*/
      1)
        set_data_dev(
          t,
          /*styles*/
          ctx2[0]
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svelte_element);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_dynamic_element.name,
    type: "child_dynamic_element",
    source: "(18:2) <svelte:element this={tag()}>",
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (TARGET === "svelte" || TARGET === "qwik")
      return create_if_block2;
    return create_else_block2;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if_block.p(ctx2, dirty);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let injectedStyleScript;
  let tag;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Render_inlined_styles", slots, []);
  let { styles } = $$props;
  $$self.$$.on_mount.push(function() {
    if (styles === void 0 && !("styles" in $$props || $$self.$$.bound[$$self.$$.props["styles"]])) {
      console.warn("<Render_inlined_styles> was created without expected prop 'styles'");
    }
  });
  const writable_props = ["styles"];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<Render_inlined_styles> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("styles" in $$props2)
      $$invalidate(0, styles = $$props2.styles);
  };
  $$self.$capture_state = () => ({ TARGET, styles, tag, injectedStyleScript });
  $$self.$inject_state = ($$props2) => {
    if ("styles" in $$props2)
      $$invalidate(0, styles = $$props2.styles);
    if ("tag" in $$props2)
      $$invalidate(1, tag = $$props2.tag);
    if ("injectedStyleScript" in $$props2)
      $$invalidate(2, injectedStyleScript = $$props2.injectedStyleScript);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*tag, styles*/
    3) {
      $:
        $$invalidate(2, injectedStyleScript = () => {
          return `<${tag()}>${styles}</${tag()}>`;
        });
    }
  };
  $:
    $$invalidate(1, tag = () => {
      return "style";
    });
  return [styles, tag, injectedStyleScript];
}
var Render_inlined_styles = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, { styles: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Render_inlined_styles",
      options,
      id: create_fragment2.name
    });
  }
  get styles() {
    throw new Error("<Render_inlined_styles>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set styles(value) {
    throw new Error("<Render_inlined_styles>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var render_inlined_styles_default = Render_inlined_styles;

// node_modules/@builder.io/sdk-svelte/package/components/render-block/block-styles.svelte
function create_if_block3(ctx) {
  let renderinlinedstyles;
  let current;
  renderinlinedstyles = new render_inlined_styles_default({
    props: { styles: (
      /*css*/
      ctx[0]()
    ) },
    $$inline: true
  });
  const block_1 = {
    c: function create() {
      create_component(renderinlinedstyles.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(renderinlinedstyles.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(renderinlinedstyles, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const renderinlinedstyles_changes = {};
      if (dirty & /*css*/
      1)
        renderinlinedstyles_changes.styles = /*css*/
        ctx2[0]();
      renderinlinedstyles.$set(renderinlinedstyles_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(renderinlinedstyles.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(renderinlinedstyles.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(renderinlinedstyles, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_if_block3.name,
    type: "if",
    source: '(63:0) {#if TARGET !== \\"reactNative\\" && css() && canShowBlock()}',
    ctx
  });
  return block_1;
}
function create_fragment3(ctx) {
  let show_if = TARGET !== "reactNative" && /*css*/
  ctx[0]() && /*canShowBlock*/
  ctx[1]();
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block3(ctx);
  const block_1 = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*css, canShowBlock*/
      3)
        show_if = TARGET !== "reactNative" && /*css*/
        ctx2[0]() && /*canShowBlock*/
        ctx2[1]();
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*css, canShowBlock*/
          3) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block3(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block_1;
}
function instance3($$self, $$props, $$invalidate) {
  let useBlock;
  let canShowBlock;
  let css;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Block_styles", slots, []);
  let { block } = $$props;
  let { context } = $$props;
  $$self.$$.on_mount.push(function() {
    if (block === void 0 && !("block" in $$props || $$self.$$.bound[$$self.$$.props["block"]])) {
      console.warn("<Block_styles> was created without expected prop 'block'");
    }
    if (context === void 0 && !("context" in $$props || $$self.$$.bound[$$self.$$.props["context"]])) {
      console.warn("<Block_styles> was created without expected prop 'context'");
    }
  });
  const writable_props = ["block", "context"];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<Block_styles> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("block" in $$props2)
      $$invalidate(2, block = $$props2.block);
    if ("context" in $$props2)
      $$invalidate(3, context = $$props2.context);
  };
  $$self.$capture_state = () => ({
    getMaxWidthQueryForSize,
    getSizesForBreakpoints,
    TARGET,
    getProcessedBlock,
    createCssClass,
    checkIsDefined,
    RenderInlinedStyles: render_inlined_styles_default,
    block,
    context,
    useBlock,
    css,
    canShowBlock
  });
  $$self.$inject_state = ($$props2) => {
    if ("block" in $$props2)
      $$invalidate(2, block = $$props2.block);
    if ("context" in $$props2)
      $$invalidate(3, context = $$props2.context);
    if ("useBlock" in $$props2)
      $$invalidate(4, useBlock = $$props2.useBlock);
    if ("css" in $$props2)
      $$invalidate(0, css = $$props2.css);
    if ("canShowBlock" in $$props2)
      $$invalidate(1, canShowBlock = $$props2.canShowBlock);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*block, context*/
    12) {
      $:
        $$invalidate(4, useBlock = () => {
          return getProcessedBlock({
            block,
            state: context.state,
            context: context.context,
            shouldEvaluateBindings: true
          });
        });
    }
    if ($$self.$$.dirty & /*useBlock*/
    16) {
      $:
        $$invalidate(1, canShowBlock = () => {
          if (checkIsDefined(useBlock().hide)) {
            return !useBlock().hide;
          }
          if (checkIsDefined(useBlock().show)) {
            return useBlock().show;
          }
          return true;
        });
    }
    if ($$self.$$.dirty & /*useBlock, context*/
    24) {
      $:
        $$invalidate(0, css = () => {
          var _a;
          const styles = useBlock().responsiveStyles;
          const content = context.content;
          const sizesWithUpdatedBreakpoints = getSizesForBreakpoints(((_a = content == null ? void 0 : content.meta) == null ? void 0 : _a.breakpoints) || {});
          const largeStyles = styles == null ? void 0 : styles.large;
          const mediumStyles = styles == null ? void 0 : styles.medium;
          const smallStyles = styles == null ? void 0 : styles.small;
          const className = useBlock().id;
          const largeStylesClass = largeStyles ? createCssClass({ className, styles: largeStyles }) : "";
          const mediumStylesClass = mediumStyles ? createCssClass({
            className,
            styles: mediumStyles,
            mediaQuery: getMaxWidthQueryForSize("medium", sizesWithUpdatedBreakpoints)
          }) : "";
          const smallStylesClass = smallStyles ? createCssClass({
            className,
            styles: smallStyles,
            mediaQuery: getMaxWidthQueryForSize("small", sizesWithUpdatedBreakpoints)
          }) : "";
          return [largeStylesClass, mediumStylesClass, smallStylesClass].join(" ");
        });
    }
  };
  return [css, canShowBlock, block, context, useBlock];
}
var Block_styles = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, { block: 2, context: 3 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Block_styles",
      options,
      id: create_fragment3.name
    });
  }
  get block() {
    throw new Error("<Block_styles>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set block(value) {
    throw new Error("<Block_styles>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get context() {
    throw new Error("<Block_styles>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set context(value) {
    throw new Error("<Block_styles>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var block_styles_default = Block_styles;

// node_modules/@builder.io/sdk-svelte/package/functions/event-handler-name.js
var getEventHandlerName = (key2) => `on:${key2.toLowerCase()}`;

// node_modules/@builder.io/sdk-svelte/package/functions/get-block-actions-handler.js
var createEventHandler = (value, options) => (event) => evaluate({
  code: value,
  context: options.context,
  state: options.state,
  event,
  isExpression: false
});

// node_modules/@builder.io/sdk-svelte/package/functions/get-block-actions.js
function getBlockActions(options) {
  const obj = {};
  const optionActions = options.block.actions ?? {};
  for (const key2 in optionActions) {
    if (!optionActions.hasOwnProperty(key2)) {
      continue;
    }
    const value = optionActions[key2];
    obj[getEventHandlerName(key2)] = createEventHandler(value, options);
  }
  return obj;
}

// node_modules/@builder.io/sdk-svelte/package/functions/get-block-component-options.js
function getBlockComponentOptions(block) {
  var _a;
  return {
    ...(_a = block.component) == null ? void 0 : _a.options,
    ...block.options,
    /**
     * Our built-in components frequently make use of the block, so we provide all of it under `builderBlock`
     */
    builderBlock: block
  };
}

// node_modules/@builder.io/sdk-svelte/package/functions/transform-block-properties.js
function transformBlockProperties(properties) {
  return properties;
}

// node_modules/@builder.io/sdk-svelte/package/functions/get-block-properties.js
function getBlockProperties(block) {
  var _a;
  const properties = {
    ...block.properties,
    "builder-id": block.id,
    style: getStyleAttribute(block.style),
    class: [block.id, "builder-block", block.class, (_a = block.properties) == null ? void 0 : _a.class].filter(Boolean).join(" ")
  };
  return transformBlockProperties(properties);
}
function getStyleAttribute(style) {
  if (!style) {
    return void 0;
  }
  switch (TARGET) {
    case "svelte":
    case "vue2":
    case "vue3":
    case "solid":
      return convertStyleMapToCSSArray(style).join(" ");
    case "qwik":
    case "reactNative":
    case "react":
      return style;
  }
}

// node_modules/@builder.io/sdk-svelte/package/functions/get-block-tag.js
function getBlockTag(block) {
  return block.tagName || "div";
}

// node_modules/@builder.io/sdk-svelte/package/components/render-block/render-block.helpers.js
var EMPTY_HTML_ELEMENTS = [
  "area",
  "base",
  "br",
  "col",
  "embed",
  "hr",
  "img",
  "input",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
];
var isEmptyHtmlElement = (tagName) => {
  return typeof tagName === "string" && EMPTY_HTML_ELEMENTS.includes(tagName.toLowerCase());
};
var getComponent = ({ block, context }) => {
  var _a;
  const componentName = (_a = getProcessedBlock({
    block,
    state: context.state,
    context: context.context,
    shouldEvaluateBindings: false
  }).component) == null ? void 0 : _a.name;
  if (!componentName) {
    return null;
  }
  const ref = context.registeredComponents[componentName];
  if (!ref) {
    console.warn(`
      Could not find a registered component named "${componentName}". 
      If you registered it, is the file that registered it imported by the file that needs to render it?`);
    return void 0;
  } else {
    return ref;
  }
};
var getRepeatItemData = ({ block, context }) => {
  const { repeat, ...blockWithoutRepeat } = block;
  if (!(repeat == null ? void 0 : repeat.collection)) {
    return void 0;
  }
  const itemsArray = evaluate({
    code: repeat.collection,
    state: context.state,
    context: context.context
  });
  if (!Array.isArray(itemsArray)) {
    return void 0;
  }
  const collectionName = repeat.collection.split(".").pop();
  const itemNameToUse = repeat.itemName || (collectionName ? collectionName + "Item" : "item");
  const repeatArray = itemsArray.map((item, index) => ({
    context: {
      ...context,
      state: {
        ...context.state,
        $index: index,
        $item: item,
        [itemNameToUse]: item,
        [`$${itemNameToUse}Index`]: index
      }
    },
    block: blockWithoutRepeat
  }));
  return repeatArray;
};

// node_modules/@builder.io/sdk-svelte/package/components/render-block/render-component.svelte
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[4] = list[i];
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[4] = list[i];
  return child_ctx;
}
function create_if_block4(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    /*componentOptions*/
    ctx[1]
  ];
  var switch_value = (
    /*componentRef*/
    ctx[0]
  );
  function switch_props(ctx2, dirty) {
    let switch_instance_props = {
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx: ctx2 }
    };
    if (dirty !== void 0 && dirty & /*componentOptions*/
    2) {
      switch_instance_props = get_spread_update(switch_instance_spread_levels, [get_spread_object(
        /*componentOptions*/
        ctx2[1]
      )]);
    } else {
      for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
        switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
      }
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*componentRef*/
      1 && switch_value !== (switch_value = /*componentRef*/
      ctx2[0])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = dirty & /*componentOptions*/
        2 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(
          /*componentOptions*/
          ctx2[1]
        )]) : {};
        if (dirty & /*$$scope, blockChildren, context*/
        524) {
          switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
        }
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block4.name,
    type: "if",
    source: "(13:0) {#if componentRef}",
    ctx
  });
  return block;
}
function create_each_block_1(key_1, ctx) {
  let first;
  let renderblock;
  let current;
  renderblock = new render_block_default({
    props: {
      block: (
        /*child*/
        ctx[4]
      ),
      context: (
        /*context*/
        ctx[3]
      )
    },
    $$inline: true
  });
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      create_component(renderblock.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      first = empty();
      claim_component(renderblock.$$.fragment, nodes);
      this.h();
    },
    h: function hydrate() {
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, first, anchor);
      mount_component(renderblock, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const renderblock_changes = {};
      if (dirty & /*blockChildren*/
      4)
        renderblock_changes.block = /*child*/
        ctx[4];
      if (dirty & /*context*/
      8)
        renderblock_changes.context = /*context*/
        ctx[3];
      renderblock.$set(renderblock_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(renderblock.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(renderblock.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(first);
      }
      destroy_component(renderblock, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_1.name,
    type: "each",
    source: '(15:4) {#each blockChildren as child (\\"render-block-\\" + child.id)}',
    ctx
  });
  return block;
}
function create_each_block(key_1, ctx) {
  let first;
  let blockstyles;
  let current;
  blockstyles = new block_styles_default({
    props: {
      block: (
        /*child*/
        ctx[4]
      ),
      context: (
        /*context*/
        ctx[3]
      )
    },
    $$inline: true
  });
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      create_component(blockstyles.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      first = empty();
      claim_component(blockstyles.$$.fragment, nodes);
      this.h();
    },
    h: function hydrate() {
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, first, anchor);
      mount_component(blockstyles, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const blockstyles_changes = {};
      if (dirty & /*blockChildren*/
      4)
        blockstyles_changes.block = /*child*/
        ctx[4];
      if (dirty & /*context*/
      8)
        blockstyles_changes.context = /*context*/
        ctx[3];
      blockstyles.$set(blockstyles_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(blockstyles.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(blockstyles.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(first);
      }
      destroy_component(blockstyles, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: '(19:4) {#each blockChildren as child (\\"block-style-\\" + child.id)}',
    ctx
  });
  return block;
}
function create_default_slot(ctx) {
  let each_blocks_1 = [];
  let each0_lookup = /* @__PURE__ */ new Map();
  let t;
  let each_blocks = [];
  let each1_lookup = /* @__PURE__ */ new Map();
  let each1_anchor;
  let current;
  let each_value_1 = ensure_array_like_dev(
    /*blockChildren*/
    ctx[2]
  );
  const get_key = (ctx2) => "render-block-" + /*child*/
  ctx2[4].id;
  validate_each_keys(ctx, each_value_1, get_each_context_1, get_key);
  for (let i = 0; i < each_value_1.length; i += 1) {
    let child_ctx = get_each_context_1(ctx, each_value_1, i);
    let key2 = get_key(child_ctx);
    each0_lookup.set(key2, each_blocks_1[i] = create_each_block_1(key2, child_ctx));
  }
  let each_value = ensure_array_like_dev(
    /*blockChildren*/
    ctx[2]
  );
  const get_key_1 = (ctx2) => "block-style-" + /*child*/
  ctx2[4].id;
  validate_each_keys(ctx, each_value, get_each_context, get_key_1);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context(ctx, each_value, i);
    let key2 = get_key_1(child_ctx);
    each1_lookup.set(key2, each_blocks[i] = create_each_block(key2, child_ctx));
  }
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      t = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].l(nodes);
      }
      t = claim_space(nodes);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        if (each_blocks_1[i]) {
          each_blocks_1[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, t, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*blockChildren, context*/
      12) {
        each_value_1 = ensure_array_like_dev(
          /*blockChildren*/
          ctx2[2]
        );
        group_outros();
        validate_each_keys(ctx2, each_value_1, get_each_context_1, get_key);
        each_blocks_1 = update_keyed_each(each_blocks_1, dirty, get_key, 1, ctx2, each_value_1, each0_lookup, t.parentNode, outro_and_destroy_block, create_each_block_1, t, get_each_context_1);
        check_outros();
      }
      if (dirty & /*blockChildren, context*/
      12) {
        each_value = ensure_array_like_dev(
          /*blockChildren*/
          ctx2[2]
        );
        group_outros();
        validate_each_keys(ctx2, each_value, get_each_context, get_key_1);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key_1, 1, ctx2, each_value, each1_lookup, each1_anchor.parentNode, outro_and_destroy_block, create_each_block, each1_anchor, get_each_context);
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks_1[i]);
      }
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        transition_out(each_blocks_1[i]);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
        detach_dev(each1_anchor);
      }
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].d(detaching);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d(detaching);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: "(14:2) <svelte:component this={componentRef} {...componentOptions}>",
    ctx
  });
  return block;
}
function create_fragment4(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*componentRef*/
    ctx[0] && create_if_block4(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*componentRef*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*componentRef*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block4(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Render_component", slots, []);
  let { componentRef } = $$props;
  let { componentOptions } = $$props;
  let { blockChildren } = $$props;
  let { context } = $$props;
  $$self.$$.on_mount.push(function() {
    if (componentRef === void 0 && !("componentRef" in $$props || $$self.$$.bound[$$self.$$.props["componentRef"]])) {
      console.warn("<Render_component> was created without expected prop 'componentRef'");
    }
    if (componentOptions === void 0 && !("componentOptions" in $$props || $$self.$$.bound[$$self.$$.props["componentOptions"]])) {
      console.warn("<Render_component> was created without expected prop 'componentOptions'");
    }
    if (blockChildren === void 0 && !("blockChildren" in $$props || $$self.$$.bound[$$self.$$.props["blockChildren"]])) {
      console.warn("<Render_component> was created without expected prop 'blockChildren'");
    }
    if (context === void 0 && !("context" in $$props || $$self.$$.bound[$$self.$$.props["context"]])) {
      console.warn("<Render_component> was created without expected prop 'context'");
    }
  });
  const writable_props = ["componentRef", "componentOptions", "blockChildren", "context"];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<Render_component> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("componentRef" in $$props2)
      $$invalidate(0, componentRef = $$props2.componentRef);
    if ("componentOptions" in $$props2)
      $$invalidate(1, componentOptions = $$props2.componentOptions);
    if ("blockChildren" in $$props2)
      $$invalidate(2, blockChildren = $$props2.blockChildren);
    if ("context" in $$props2)
      $$invalidate(3, context = $$props2.context);
  };
  $$self.$capture_state = () => ({
    BlockStyles: block_styles_default,
    RenderBlock: render_block_default,
    componentRef,
    componentOptions,
    blockChildren,
    context
  });
  $$self.$inject_state = ($$props2) => {
    if ("componentRef" in $$props2)
      $$invalidate(0, componentRef = $$props2.componentRef);
    if ("componentOptions" in $$props2)
      $$invalidate(1, componentOptions = $$props2.componentOptions);
    if ("blockChildren" in $$props2)
      $$invalidate(2, blockChildren = $$props2.blockChildren);
    if ("context" in $$props2)
      $$invalidate(3, context = $$props2.context);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [componentRef, componentOptions, blockChildren, context];
}
var Render_component = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment4, safe_not_equal, {
      componentRef: 0,
      componentOptions: 1,
      blockChildren: 2,
      context: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Render_component",
      options,
      id: create_fragment4.name
    });
  }
  get componentRef() {
    throw new Error("<Render_component>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set componentRef(value) {
    throw new Error("<Render_component>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get componentOptions() {
    throw new Error("<Render_component>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set componentOptions(value) {
    throw new Error("<Render_component>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get blockChildren() {
    throw new Error("<Render_component>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set blockChildren(value) {
    throw new Error("<Render_component>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get context() {
    throw new Error("<Render_component>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set context(value) {
    throw new Error("<Render_component>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var render_component_default = Render_component;

// node_modules/@builder.io/sdk-svelte/package/components/render-block/render-repeated-block.svelte
function create_fragment5(ctx) {
  let renderblock;
  let current;
  renderblock = new render_block_default({
    props: {
      block: (
        /*block*/
        ctx[0]
      ),
      context: (
        /*repeatContext*/
        ctx[1]
      )
    },
    $$inline: true
  });
  const block_1 = {
    c: function create() {
      create_component(renderblock.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(renderblock.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(renderblock, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const renderblock_changes = {};
      if (dirty & /*block*/
      1)
        renderblock_changes.block = /*block*/
        ctx2[0];
      if (dirty & /*repeatContext*/
      2)
        renderblock_changes.context = /*repeatContext*/
        ctx2[1];
      renderblock.$set(renderblock_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(renderblock.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(renderblock.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(renderblock, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block_1;
}
function instance5($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Render_repeated_block", slots, []);
  let { block } = $$props;
  let { repeatContext } = $$props;
  setContext(builder_context_default.key, {
    content: repeatContext.content,
    state: repeatContext.state,
    setState: repeatContext.setState,
    context: repeatContext.context,
    apiKey: repeatContext.apiKey,
    registeredComponents: repeatContext.registeredComponents,
    inheritedStyles: repeatContext.inheritedStyles
  });
  $$self.$$.on_mount.push(function() {
    if (block === void 0 && !("block" in $$props || $$self.$$.bound[$$self.$$.props["block"]])) {
      console.warn("<Render_repeated_block> was created without expected prop 'block'");
    }
    if (repeatContext === void 0 && !("repeatContext" in $$props || $$self.$$.bound[$$self.$$.props["repeatContext"]])) {
      console.warn("<Render_repeated_block> was created without expected prop 'repeatContext'");
    }
  });
  const writable_props = ["block", "repeatContext"];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<Render_repeated_block> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("block" in $$props2)
      $$invalidate(0, block = $$props2.block);
    if ("repeatContext" in $$props2)
      $$invalidate(1, repeatContext = $$props2.repeatContext);
  };
  $$self.$capture_state = () => ({
    setContext,
    BuilderContext: builder_context_default,
    RenderBlock: render_block_default,
    block,
    repeatContext
  });
  $$self.$inject_state = ($$props2) => {
    if ("block" in $$props2)
      $$invalidate(0, block = $$props2.block);
    if ("repeatContext" in $$props2)
      $$invalidate(1, repeatContext = $$props2.repeatContext);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [block, repeatContext];
}
var Render_repeated_block = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance5, create_fragment5, safe_not_equal, { block: 0, repeatContext: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Render_repeated_block",
      options,
      id: create_fragment5.name
    });
  }
  get block() {
    throw new Error("<Render_repeated_block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set block(value) {
    throw new Error("<Render_repeated_block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get repeatContext() {
    throw new Error("<Render_repeated_block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set repeatContext(value) {
    throw new Error("<Render_repeated_block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var render_repeated_block_default = Render_repeated_block;

// node_modules/@builder.io/sdk-svelte/package/functions/extract-text-styles.js
var TEXT_STYLE_KEYS = [
  "color",
  "whiteSpace",
  "direction",
  "hyphens",
  "overflowWrap"
];
var isTextStyle = (key2) => {
  return TEXT_STYLE_KEYS.includes(key2) || key2.startsWith("font") || key2.startsWith("text") || key2.startsWith("letter") || key2.startsWith("line") || key2.startsWith("word") || key2.startsWith("writing");
};
var extractTextStyles = (styles) => {
  const textStyles = {};
  Object.entries(styles).forEach(([key2, value]) => {
    if (isTextStyle(key2)) {
      textStyles[key2] = value;
    }
  });
  return textStyles;
};

// node_modules/@builder.io/sdk-svelte/package/functions/sanitize-react-native-block-styles.js
var propertiesThatMustBeNumber = /* @__PURE__ */ new Set(["lineHeight"]);
var displayValues = /* @__PURE__ */ new Set(["flex", "none"]);
var SHOW_WARNINGS = false;
var normalizeNumber = (value) => {
  if (Number.isNaN(value)) {
    return void 0;
  } else if (value < 0) {
    return 0;
  } else {
    return value;
  }
};
var sanitizeReactNativeBlockStyles = (styles) => {
  return Object.keys(styles).reduce((acc, key2) => {
    const propertyValue = styles[key2];
    if (key2 === "display" && !displayValues.has(propertyValue)) {
      if (SHOW_WARNINGS) {
        console.warn(`Style value for key "display" must be "flex" or "none" but had ${propertyValue}`);
      }
      return acc;
    }
    if (propertiesThatMustBeNumber.has(key2) && typeof propertyValue !== "number") {
      if (SHOW_WARNINGS) {
        console.warn(`Style key ${key2} must be a number, but had value \`${styles[key2]}\``);
      }
      return acc;
    }
    if (typeof propertyValue === "string") {
      const isPixelUnit = propertyValue.match(/^-?(\d*)(\.?)(\d*)*px$/);
      if (isPixelUnit) {
        const newValue = parseFloat(propertyValue);
        const normalizedValue = normalizeNumber(newValue);
        if (normalizedValue) {
          return { ...acc, [key2]: normalizedValue };
        } else {
          return acc;
        }
      } else if (propertyValue === "0") {
        return { ...acc, [key2]: 0 };
      }
    }
    return { ...acc, [key2]: propertyValue };
  }, {});
};

// node_modules/@builder.io/sdk-svelte/package/functions/get-react-native-block-styles.js
function getReactNativeBlockStyles({ block, context, blockStyles }) {
  const responsiveStyles = block.responsiveStyles;
  if (!responsiveStyles) {
    return {};
  }
  const styles = {
    // recursively apply inherited styles so that they can be passed down to children `Text` blocks
    ...context.inheritedStyles,
    ...responsiveStyles.large || {},
    ...responsiveStyles.medium || {},
    ...responsiveStyles.small || {},
    ...blockStyles
  };
  const newStyles = sanitizeReactNativeBlockStyles(styles);
  return newStyles;
}

// node_modules/@builder.io/sdk-svelte/package/components/render-block/render-block.svelte
var { Object: Object_12, console: console_1 } = globals;
var file3 = "node_modules\\@builder.io\\sdk-svelte\\package\\components\\render-block\\render-block.svelte";
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[14] = list[i];
  return child_ctx;
}
function get_each_context_12(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[14] = list[i];
  return child_ctx;
}
function get_each_context_2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[19] = list[i];
  child_ctx[21] = i;
  return child_ctx;
}
function create_if_block5(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_1, create_else_block3];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    var _a;
    if (!/*component*/
    ((_a = ctx2[8]) == null ? void 0 : _a.noWrap))
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block_1 = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if_block.p(ctx2, dirty);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_if_block5.name,
    type: "if",
    source: "(161:0) {#if canShowBlock()}",
    ctx
  });
  return block_1;
}
function create_else_block3(ctx) {
  let rendercomponent;
  let current;
  const rendercomponent_spread_levels = [
    /*renderComponentProps*/
    ctx[4]()
  ];
  let rendercomponent_props = {};
  for (let i = 0; i < rendercomponent_spread_levels.length; i += 1) {
    rendercomponent_props = assign(rendercomponent_props, rendercomponent_spread_levels[i]);
  }
  rendercomponent = new render_component_default({
    props: rendercomponent_props,
    $$inline: true
  });
  const block_1 = {
    c: function create() {
      create_component(rendercomponent.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(rendercomponent.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(rendercomponent, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const rendercomponent_changes = dirty & /*renderComponentProps*/
      16 ? get_spread_update(rendercomponent_spread_levels, [get_spread_object(
        /*renderComponentProps*/
        ctx2[4]()
      )]) : {};
      rendercomponent.$set(rendercomponent_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(rendercomponent.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(rendercomponent.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(rendercomponent, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_else_block3.name,
    type: "else",
    source: "(186:2) {:else}",
    ctx
  });
  return block_1;
}
function create_if_block_1(ctx) {
  let show_if_2 = isEmptyHtmlElement(
    /*tag*/
    ctx[6]()
  );
  let t0;
  let show_if_1 = !isEmptyHtmlElement(
    /*tag*/
    ctx[6]()
  ) && /*repeatItemData*/
  ctx[9];
  let t1;
  let show_if = !isEmptyHtmlElement(
    /*tag*/
    ctx[6]()
  ) && !/*repeatItemData*/
  ctx[9];
  let if_block2_anchor;
  let current;
  let if_block0 = show_if_2 && create_if_block_4(ctx);
  let if_block1 = show_if_1 && create_if_block_3(ctx);
  let if_block2 = show_if && create_if_block_2(ctx);
  const block_1 = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      if_block2_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block0)
        if_block0.l(nodes);
      t0 = claim_space(nodes);
      if (if_block1)
        if_block1.l(nodes);
      t1 = claim_space(nodes);
      if (if_block2)
        if_block2.l(nodes);
      if_block2_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_hydration_dev(target, t0, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_hydration_dev(target, t1, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert_hydration_dev(target, if_block2_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*tag*/
      64)
        show_if_2 = isEmptyHtmlElement(
          /*tag*/
          ctx2[6]()
        );
      if (show_if_2) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_4(ctx2);
          if_block0.c();
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (dirty & /*tag*/
      64)
        show_if_1 = !isEmptyHtmlElement(
          /*tag*/
          ctx2[6]()
        ) && /*repeatItemData*/
        ctx2[9];
      if (show_if_1) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*tag*/
          64) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_3(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t1.parentNode, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (dirty & /*tag*/
      64)
        show_if = !isEmptyHtmlElement(
          /*tag*/
          ctx2[6]()
        ) && !/*repeatItemData*/
        ctx2[9];
      if (show_if) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & /*tag*/
          64) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_2(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(t1);
        detach_dev(if_block2_anchor);
      }
      if (if_block0)
        if_block0.d(detaching);
      if (if_block1)
        if_block1.d(detaching);
      if (if_block2)
        if_block2.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_if_block_1.name,
    type: "if",
    source: "(162:2) {#if !component?.noWrap}",
    ctx
  });
  return block_1;
}
function create_if_block_4(ctx) {
  let previous_tag = (
    /*tag*/
    ctx[6]()
  );
  let svelte_element_anchor;
  validate_dynamic_element(
    /*tag*/
    ctx[6]()
  );
  let svelte_element = (
    /*tag*/
    ctx[6]() && create_dynamic_element_1(ctx)
  );
  const block_1 = {
    c: function create() {
      if (svelte_element)
        svelte_element.c();
      svelte_element_anchor = empty();
    },
    l: function claim(nodes) {
      if (svelte_element)
        svelte_element.l(nodes);
      svelte_element_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (svelte_element)
        svelte_element.m(target, anchor);
      insert_hydration_dev(target, svelte_element_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (
        /*tag*/
        ctx2[6]()
      ) {
        if (!previous_tag) {
          svelte_element = create_dynamic_element_1(ctx2);
          previous_tag = /*tag*/
          ctx2[6]();
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else if (safe_not_equal(
          previous_tag,
          /*tag*/
          ctx2[6]()
        )) {
          svelte_element.d(1);
          validate_dynamic_element(
            /*tag*/
            ctx2[6]()
          );
          svelte_element = create_dynamic_element_1(ctx2);
          previous_tag = /*tag*/
          ctx2[6]();
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else {
          svelte_element.p(ctx2, dirty);
        }
      } else if (previous_tag) {
        svelte_element.d(1);
        svelte_element = null;
        previous_tag = /*tag*/
        ctx2[6]();
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svelte_element_anchor);
      }
      if (svelte_element)
        svelte_element.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_if_block_4.name,
    type: "if",
    source: "(163:4) {#if isEmptyHtmlElement(tag())}",
    ctx
  });
  return block_1;
}
function create_dynamic_element_1(ctx) {
  let svelte_element;
  let setAttrs_action;
  let mounted;
  let dispose;
  let svelte_element_levels = [
    /*attributes*/
    ctx[0]()
  ];
  let svelte_element_data = {};
  for (let i = 0; i < svelte_element_levels.length; i += 1) {
    svelte_element_data = assign(svelte_element_data, svelte_element_levels[i]);
  }
  const block_1 = {
    c: function create() {
      svelte_element = element(
        /*tag*/
        ctx[6]()
      );
      this.h();
    },
    l: function claim(nodes) {
      svelte_element = claim_element(
        nodes,
        /*tag*/
        (ctx[6]() || "null").toUpperCase(),
        {}
      );
      children(svelte_element).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_dynamic_element_data(
        /*tag*/
        ctx[6]()
      )(svelte_element, svelte_element_data);
      add_location(svelte_element, file3, 163, 6, 5574);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svelte_element, anchor);
      if (!mounted) {
        dispose = action_destroyer(setAttrs_action = /*setAttrs*/
        ctx[7].call(
          null,
          svelte_element,
          /*actions*/
          ctx[2]()
        ));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_dynamic_element_data(
        /*tag*/
        ctx2[6]()
      )(svelte_element, svelte_element_data = get_spread_update(svelte_element_levels, [dirty & /*attributes*/
      1 && /*attributes*/
      ctx2[0]()]));
      if (setAttrs_action && is_function(setAttrs_action.update) && dirty & /*actions*/
      4)
        setAttrs_action.update.call(
          null,
          /*actions*/
          ctx2[2]()
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svelte_element);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_dynamic_element_1.name,
    type: "child_dynamic_element",
    source: "(164:6) <svelte:element this={tag()} {...attributes()} use:setAttrs={actions()} />",
    ctx
  });
  return block_1;
}
function create_if_block_3(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value_2 = ensure_array_like_dev(
    /*repeatItemData*/
    ctx[9]
  );
  const get_key = (ctx2) => (
    /*index*/
    ctx2[21]
  );
  validate_each_keys(ctx, each_value_2, get_each_context_2, get_key);
  for (let i = 0; i < each_value_2.length; i += 1) {
    let child_ctx = get_each_context_2(ctx, each_value_2, i);
    let key2 = get_key(child_ctx);
    each_1_lookup.set(key2, each_blocks[i] = create_each_block_2(key2, child_ctx));
  }
  const block_1 = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*repeatItemData*/
      512) {
        each_value_2 = ensure_array_like_dev(
          /*repeatItemData*/
          ctx2[9]
        );
        group_outros();
        validate_each_keys(ctx2, each_value_2, get_each_context_2, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value_2, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block_2, each_1_anchor, get_each_context_2);
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_2.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d(detaching);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_if_block_3.name,
    type: "if",
    source: "(167:4) {#if !isEmptyHtmlElement(tag()) && repeatItemData}",
    ctx
  });
  return block_1;
}
function create_each_block_2(key_1, ctx) {
  let first;
  let renderrepeatedblock;
  let current;
  renderrepeatedblock = new render_repeated_block_default({
    props: {
      repeatContext: (
        /*data*/
        ctx[19].context
      ),
      block: (
        /*data*/
        ctx[19].block
      )
    },
    $$inline: true
  });
  const block_1 = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      create_component(renderrepeatedblock.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      first = empty();
      claim_component(renderrepeatedblock.$$.fragment, nodes);
      this.h();
    },
    h: function hydrate() {
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, first, anchor);
      mount_component(renderrepeatedblock, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(renderrepeatedblock.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(renderrepeatedblock.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(first);
      }
      destroy_component(renderrepeatedblock, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_each_block_2.name,
    type: "each",
    source: "(168:6) {#each repeatItemData as data, index (index)}",
    ctx
  });
  return block_1;
}
function create_if_block_2(ctx) {
  let previous_tag = (
    /*tag*/
    ctx[6]()
  );
  let svelte_element_anchor;
  let current;
  validate_dynamic_element(
    /*tag*/
    ctx[6]()
  );
  validate_void_dynamic_element(
    /*tag*/
    ctx[6]()
  );
  let svelte_element = (
    /*tag*/
    ctx[6]() && create_dynamic_element2(ctx)
  );
  const block_1 = {
    c: function create() {
      if (svelte_element)
        svelte_element.c();
      svelte_element_anchor = empty();
    },
    l: function claim(nodes) {
      if (svelte_element)
        svelte_element.l(nodes);
      svelte_element_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (svelte_element)
        svelte_element.m(target, anchor);
      insert_hydration_dev(target, svelte_element_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (
        /*tag*/
        ctx2[6]()
      ) {
        if (!previous_tag) {
          svelte_element = create_dynamic_element2(ctx2);
          previous_tag = /*tag*/
          ctx2[6]();
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else if (safe_not_equal(
          previous_tag,
          /*tag*/
          ctx2[6]()
        )) {
          svelte_element.d(1);
          validate_dynamic_element(
            /*tag*/
            ctx2[6]()
          );
          validate_void_dynamic_element(
            /*tag*/
            ctx2[6]()
          );
          svelte_element = create_dynamic_element2(ctx2);
          previous_tag = /*tag*/
          ctx2[6]();
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else {
          svelte_element.p(ctx2, dirty);
        }
      } else if (previous_tag) {
        svelte_element.d(1);
        svelte_element = null;
        previous_tag = /*tag*/
        ctx2[6]();
      }
    },
    i: noop,
    o: function outro(local) {
      transition_out(svelte_element, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svelte_element_anchor);
      }
      if (svelte_element)
        svelte_element.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_if_block_2.name,
    type: "if",
    source: "(173:4) {#if !isEmptyHtmlElement(tag()) && !repeatItemData}",
    ctx
  });
  return block_1;
}
function create_each_block_12(key_1, ctx) {
  let first;
  let render_block;
  let current;
  render_block = new Render_block({
    props: {
      block: (
        /*child*/
        ctx[14]
      ),
      context: (
        /*childrenContext*/
        ctx[1]()
      )
    },
    $$inline: true
  });
  const block_1 = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      create_component(render_block.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      first = empty();
      claim_component(render_block.$$.fragment, nodes);
      this.h();
    },
    h: function hydrate() {
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, first, anchor);
      mount_component(render_block, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const render_block_changes = {};
      if (dirty & /*childrenWithoutParentComponent*/
      8)
        render_block_changes.block = /*child*/
        ctx[14];
      if (dirty & /*childrenContext*/
      2)
        render_block_changes.context = /*childrenContext*/
        ctx[1]();
      render_block.$set(render_block_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(render_block.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(render_block.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(first);
      }
      destroy_component(render_block, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_each_block_12.name,
    type: "each",
    source: '(177:8) {#each childrenWithoutParentComponent() as child (\\"render-block-\\" + child.id)}',
    ctx
  });
  return block_1;
}
function create_each_block2(key_1, ctx) {
  let first;
  let blockstyles;
  let current;
  blockstyles = new block_styles_default({
    props: {
      block: (
        /*child*/
        ctx[14]
      ),
      context: (
        /*childrenContext*/
        ctx[1]()
      )
    },
    $$inline: true
  });
  const block_1 = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      create_component(blockstyles.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      first = empty();
      claim_component(blockstyles.$$.fragment, nodes);
      this.h();
    },
    h: function hydrate() {
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, first, anchor);
      mount_component(blockstyles, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const blockstyles_changes = {};
      if (dirty & /*childrenWithoutParentComponent*/
      8)
        blockstyles_changes.block = /*child*/
        ctx[14];
      if (dirty & /*childrenContext*/
      2)
        blockstyles_changes.context = /*childrenContext*/
        ctx[1]();
      blockstyles.$set(blockstyles_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(blockstyles.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(blockstyles.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(first);
      }
      destroy_component(blockstyles, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_each_block2.name,
    type: "each",
    source: '(181:8) {#each childrenWithoutParentComponent() as child (\\"block-style-\\" + child.id)}',
    ctx
  });
  return block_1;
}
function create_dynamic_element2(ctx) {
  let svelte_element;
  let rendercomponent;
  let t0;
  let each_blocks_1 = [];
  let each0_lookup = /* @__PURE__ */ new Map();
  let t1;
  let each_blocks = [];
  let each1_lookup = /* @__PURE__ */ new Map();
  let setAttrs_action;
  let current;
  let mounted;
  let dispose;
  const rendercomponent_spread_levels = [
    /*renderComponentProps*/
    ctx[4]()
  ];
  let rendercomponent_props = {};
  for (let i = 0; i < rendercomponent_spread_levels.length; i += 1) {
    rendercomponent_props = assign(rendercomponent_props, rendercomponent_spread_levels[i]);
  }
  rendercomponent = new render_component_default({
    props: rendercomponent_props,
    $$inline: true
  });
  let each_value_1 = ensure_array_like_dev(
    /*childrenWithoutParentComponent*/
    ctx[3]()
  );
  const get_key = (ctx2) => "render-block-" + /*child*/
  ctx2[14].id;
  validate_each_keys(ctx, each_value_1, get_each_context_12, get_key);
  for (let i = 0; i < each_value_1.length; i += 1) {
    let child_ctx = get_each_context_12(ctx, each_value_1, i);
    let key2 = get_key(child_ctx);
    each0_lookup.set(key2, each_blocks_1[i] = create_each_block_12(key2, child_ctx));
  }
  let each_value = ensure_array_like_dev(
    /*childrenWithoutParentComponent*/
    ctx[3]()
  );
  const get_key_1 = (ctx2) => "block-style-" + /*child*/
  ctx2[14].id;
  validate_each_keys(ctx, each_value, get_each_context2, get_key_1);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context2(ctx, each_value, i);
    let key2 = get_key_1(child_ctx);
    each1_lookup.set(key2, each_blocks[i] = create_each_block2(key2, child_ctx));
  }
  let svelte_element_levels = [
    /*attributes*/
    ctx[0]()
  ];
  let svelte_element_data = {};
  for (let i = 0; i < svelte_element_levels.length; i += 1) {
    svelte_element_data = assign(svelte_element_data, svelte_element_levels[i]);
  }
  const block_1 = {
    c: function create() {
      svelte_element = element(
        /*tag*/
        ctx[6]()
      );
      create_component(rendercomponent.$$.fragment);
      t0 = space();
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      t1 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      svelte_element = claim_element(
        nodes,
        /*tag*/
        (ctx[6]() || "null").toUpperCase(),
        {}
      );
      var svelte_element_nodes = children(svelte_element);
      claim_component(rendercomponent.$$.fragment, svelte_element_nodes);
      t0 = claim_space(svelte_element_nodes);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].l(svelte_element_nodes);
      }
      t1 = claim_space(svelte_element_nodes);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(svelte_element_nodes);
      }
      svelte_element_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_dynamic_element_data(
        /*tag*/
        ctx[6]()
      )(svelte_element, svelte_element_data);
      add_location(svelte_element, file3, 173, 6, 5934);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svelte_element, anchor);
      mount_component(rendercomponent, svelte_element, null);
      append_hydration_dev(svelte_element, t0);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        if (each_blocks_1[i]) {
          each_blocks_1[i].m(svelte_element, null);
        }
      }
      append_hydration_dev(svelte_element, t1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(svelte_element, null);
        }
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(setAttrs_action = /*setAttrs*/
        ctx[7].call(
          null,
          svelte_element,
          /*actions*/
          ctx[2]()
        ));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      const rendercomponent_changes = dirty & /*renderComponentProps*/
      16 ? get_spread_update(rendercomponent_spread_levels, [get_spread_object(
        /*renderComponentProps*/
        ctx2[4]()
      )]) : {};
      rendercomponent.$set(rendercomponent_changes);
      if (dirty & /*childrenWithoutParentComponent, childrenContext*/
      10) {
        each_value_1 = ensure_array_like_dev(
          /*childrenWithoutParentComponent*/
          ctx2[3]()
        );
        group_outros();
        validate_each_keys(ctx2, each_value_1, get_each_context_12, get_key);
        each_blocks_1 = update_keyed_each(each_blocks_1, dirty, get_key, 1, ctx2, each_value_1, each0_lookup, svelte_element, outro_and_destroy_block, create_each_block_12, t1, get_each_context_12);
        check_outros();
      }
      if (dirty & /*childrenWithoutParentComponent, childrenContext*/
      10) {
        each_value = ensure_array_like_dev(
          /*childrenWithoutParentComponent*/
          ctx2[3]()
        );
        group_outros();
        validate_each_keys(ctx2, each_value, get_each_context2, get_key_1);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key_1, 1, ctx2, each_value, each1_lookup, svelte_element, outro_and_destroy_block, create_each_block2, null, get_each_context2);
        check_outros();
      }
      set_dynamic_element_data(
        /*tag*/
        ctx2[6]()
      )(svelte_element, svelte_element_data = get_spread_update(svelte_element_levels, [dirty & /*attributes*/
      1 && /*attributes*/
      ctx2[0]()]));
      if (setAttrs_action && is_function(setAttrs_action.update) && dirty & /*actions*/
      4)
        setAttrs_action.update.call(
          null,
          /*actions*/
          ctx2[2]()
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(rendercomponent.$$.fragment, local);
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks_1[i]);
      }
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(rendercomponent.$$.fragment, local);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        transition_out(each_blocks_1[i]);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svelte_element);
      }
      destroy_component(rendercomponent);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].d();
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_dynamic_element2.name,
    type: "child_dynamic_element",
    source: "(174:6) <svelte:element this={tag()} {...attributes()} use:setAttrs={actions()}>",
    ctx
  });
  return block_1;
}
function create_fragment6(ctx) {
  let show_if = (
    /*canShowBlock*/
    ctx[5]()
  );
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block5(ctx);
  const block_1 = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*canShowBlock*/
      32)
        show_if = /*canShowBlock*/
        ctx2[5]();
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*canShowBlock*/
          32) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block5(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx
  });
  return block_1;
}
function instance6($$self, $$props, $$invalidate) {
  let tag;
  let useBlock;
  let canShowBlock;
  let proxyState;
  let actions;
  let attributes;
  let renderComponentProps;
  let childrenWithoutParentComponent;
  let childrenContext;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Render_block", slots, []);
  const setAttrs = (node, attrs = {}) => {
    const attrKeys = Object.keys(attrs);
    const setup = (attr) => node.addEventListener(attr.substr(3), attrs[attr]);
    const teardown = (attr) => node.removeEventListener(attr.substr(3), attrs[attr]);
    attrKeys.map(setup);
    return {
      update(attrs2 = {}) {
        const attrKeys2 = Object.keys(attrs2);
        attrKeys2.map(teardown);
        attrKeys2.map(setup);
      },
      destroy() {
        attrKeys.map(teardown);
      }
    };
  };
  let { block } = $$props;
  let { context } = $$props;
  let component = getComponent({ block, context });
  let repeatItemData = getRepeatItemData({ block, context });
  $$self.$$.on_mount.push(function() {
    if (block === void 0 && !("block" in $$props || $$self.$$.bound[$$self.$$.props["block"]])) {
      console_1.warn("<Render_block> was created without expected prop 'block'");
    }
    if (context === void 0 && !("context" in $$props || $$self.$$.bound[$$self.$$.props["context"]])) {
      console_1.warn("<Render_block> was created without expected prop 'context'");
    }
  });
  const writable_props = ["block", "context"];
  Object_12.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console_1.warn(`<Render_block> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("block" in $$props2)
      $$invalidate(10, block = $$props2.block);
    if ("context" in $$props2)
      $$invalidate(11, context = $$props2.context);
  };
  $$self.$capture_state = () => ({
    getBlockActions,
    getBlockComponentOptions,
    getBlockProperties,
    getBlockTag,
    getProcessedBlock,
    BlockStyles: block_styles_default,
    getComponent,
    getRepeatItemData,
    isEmptyHtmlElement,
    RenderRepeatedBlock: render_repeated_block_default,
    TARGET,
    extractTextStyles,
    RenderComponent: render_component_default,
    getReactNativeBlockStyles,
    checkIsDefined,
    setAttrs,
    block,
    context,
    component,
    repeatItemData,
    attributes,
    useBlock,
    childrenContext,
    childrenWithoutParentComponent,
    actions,
    renderComponentProps,
    proxyState,
    canShowBlock,
    tag
  });
  $$self.$inject_state = ($$props2) => {
    if ("block" in $$props2)
      $$invalidate(10, block = $$props2.block);
    if ("context" in $$props2)
      $$invalidate(11, context = $$props2.context);
    if ("component" in $$props2)
      $$invalidate(8, component = $$props2.component);
    if ("repeatItemData" in $$props2)
      $$invalidate(9, repeatItemData = $$props2.repeatItemData);
    if ("attributes" in $$props2)
      $$invalidate(0, attributes = $$props2.attributes);
    if ("useBlock" in $$props2)
      $$invalidate(12, useBlock = $$props2.useBlock);
    if ("childrenContext" in $$props2)
      $$invalidate(1, childrenContext = $$props2.childrenContext);
    if ("childrenWithoutParentComponent" in $$props2)
      $$invalidate(3, childrenWithoutParentComponent = $$props2.childrenWithoutParentComponent);
    if ("actions" in $$props2)
      $$invalidate(2, actions = $$props2.actions);
    if ("renderComponentProps" in $$props2)
      $$invalidate(4, renderComponentProps = $$props2.renderComponentProps);
    if ("proxyState" in $$props2)
      $$invalidate(13, proxyState = $$props2.proxyState);
    if ("canShowBlock" in $$props2)
      $$invalidate(5, canShowBlock = $$props2.canShowBlock);
    if ("tag" in $$props2)
      $$invalidate(6, tag = $$props2.tag);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*block, context*/
    3072) {
      $:
        $$invalidate(12, useBlock = () => {
          return repeatItemData ? block : getProcessedBlock({
            block,
            state: context.state,
            context: context.context,
            shouldEvaluateBindings: true
          });
        });
    }
    if ($$self.$$.dirty & /*useBlock*/
    4096) {
      $:
        $$invalidate(6, tag = () => {
          return getBlockTag(useBlock());
        });
    }
    if ($$self.$$.dirty & /*useBlock*/
    4096) {
      $:
        $$invalidate(5, canShowBlock = () => {
          if (checkIsDefined(useBlock().hide)) {
            return !useBlock().hide;
          }
          if (checkIsDefined(useBlock().show)) {
            return useBlock().show;
          }
          return true;
        });
    }
    if ($$self.$$.dirty & /*context*/
    2048) {
      $:
        $$invalidate(13, proxyState = () => {
          if (typeof Proxy === "undefined") {
            console.error("no Proxy available in this environment, cannot proxy state.");
            return context.state;
          }
          const useState = new Proxy(
            context.state,
            {
              set: (obj, prop, value) => {
                var _a;
                obj[prop] = value;
                (_a = context.setState) == null ? void 0 : _a.call(context, obj);
                return true;
              }
            }
          );
          return useState;
        });
    }
    if ($$self.$$.dirty & /*useBlock, proxyState, context*/
    14336) {
      $:
        $$invalidate(2, actions = () => {
          return getBlockActions({
            block: useBlock(),
            state: proxyState(),
            context: context.context
          });
        });
    }
    if ($$self.$$.dirty & /*useBlock, context*/
    6144) {
      $:
        $$invalidate(0, attributes = () => {
          const blockProperties = getBlockProperties(useBlock());
          return {
            ...blockProperties,
            ...TARGET === "reactNative" ? {
              style: getReactNativeBlockStyles({
                block: useBlock(),
                context,
                blockStyles: blockProperties.style
              })
            } : {}
          };
        });
    }
    if ($$self.$$.dirty & /*useBlock, context, attributes*/
    6145) {
      $:
        $$invalidate(1, childrenContext = () => {
          const getInheritedTextStyles = () => {
            if (TARGET !== "reactNative") {
              return {};
            }
            return extractTextStyles(getReactNativeBlockStyles({
              block: useBlock(),
              context,
              blockStyles: attributes().style
            }));
          };
          return {
            apiKey: context.apiKey,
            apiVersion: context.apiVersion,
            state: context.state,
            content: context.content,
            context: context.context,
            setState: context.setState,
            registeredComponents: context.registeredComponents,
            inheritedStyles: getInheritedTextStyles()
          };
        });
    }
    if ($$self.$$.dirty & /*useBlock, attributes, actions, childrenContext*/
    4103) {
      $:
        $$invalidate(4, renderComponentProps = () => {
          return {
            blockChildren: useBlock().children ?? [],
            componentRef: component == null ? void 0 : component.component,
            componentOptions: {
              ...getBlockComponentOptions(useBlock()),
              /**
              * These attributes are passed to the wrapper element when there is one. If `noWrap` is set to true, then
              * they are provided to the component itself directly.
              */
              ...!(component == null ? void 0 : component.noWrap) ? {} : {
                attributes: { ...attributes(), ...actions() }
              }
            },
            context: childrenContext()
          };
        });
    }
    if ($$self.$$.dirty & /*useBlock*/
    4096) {
      $:
        $$invalidate(3, childrenWithoutParentComponent = () => {
          const shouldRenderChildrenOutsideRef = !(component == null ? void 0 : component.component) && !repeatItemData;
          return shouldRenderChildrenOutsideRef ? useBlock().children ?? [] : [];
        });
    }
  };
  return [
    attributes,
    childrenContext,
    actions,
    childrenWithoutParentComponent,
    renderComponentProps,
    canShowBlock,
    tag,
    setAttrs,
    component,
    repeatItemData,
    block,
    context,
    useBlock,
    proxyState
  ];
}
var Render_block = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance6, create_fragment6, safe_not_equal, { block: 10, context: 11 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Render_block",
      options,
      id: create_fragment6.name
    });
  }
  get block() {
    throw new Error("<Render_block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set block(value) {
    throw new Error("<Render_block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get context() {
    throw new Error("<Render_block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set context(value) {
    throw new Error("<Render_block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var render_block_default = Render_block;

// node_modules/@builder.io/sdk-svelte/package/components/render-blocks.svelte
var { Object: Object_13 } = globals;
var file4 = "node_modules\\@builder.io\\sdk-svelte\\package\\components\\render-blocks.svelte";
function add_css2(target) {
  append_styles(target, "svelte-jzu5nw", ".div.svelte-jzu5nw{display:flex;flex-direction:column;align-items:stretch}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVuZGVyLWJsb2Nrcy5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBK0VFLGtCQUFLLENBQ0gsT0FBTyxDQUFFLElBQUksQ0FDYixjQUFjLENBQUUsTUFBTSxDQUN0QixXQUFXLENBQUUsT0FDZiIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJyZW5kZXItYmxvY2tzLnN2ZWx0ZSJdfQ== */");
}
function get_each_context3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[10] = list[i];
  return child_ctx;
}
function get_each_context_13(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[10] = list[i];
  return child_ctx;
}
function create_if_block_12(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value_1 = ensure_array_like_dev(
    /*blocks*/
    ctx[0]
  );
  const get_key = (ctx2) => "render-block-" + /*block*/
  ctx2[10].id;
  validate_each_keys(ctx, each_value_1, get_each_context_13, get_key);
  for (let i = 0; i < each_value_1.length; i += 1) {
    let child_ctx = get_each_context_13(ctx, each_value_1, i);
    let key2 = get_key(child_ctx);
    each_1_lookup.set(key2, each_blocks[i] = create_each_block_13(key2, child_ctx));
  }
  const block_1 = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*blocks, builderContext*/
      33) {
        each_value_1 = ensure_array_like_dev(
          /*blocks*/
          ctx2[0]
        );
        group_outros();
        validate_each_keys(ctx2, each_value_1, get_each_context_13, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value_1, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block_13, each_1_anchor, get_each_context_13);
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d(detaching);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_if_block_12.name,
    type: "if",
    source: "(66:2) {#if blocks}",
    ctx
  });
  return block_1;
}
function create_each_block_13(key_1, ctx) {
  let first;
  let renderblock;
  let current;
  renderblock = new render_block_default({
    props: {
      block: (
        /*block*/
        ctx[10]
      ),
      context: (
        /*builderContext*/
        ctx[5]
      )
    },
    $$inline: true
  });
  const block_1 = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      create_component(renderblock.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      first = empty();
      claim_component(renderblock.$$.fragment, nodes);
      this.h();
    },
    h: function hydrate() {
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, first, anchor);
      mount_component(renderblock, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const renderblock_changes = {};
      if (dirty & /*blocks*/
      1)
        renderblock_changes.block = /*block*/
        ctx[10];
      renderblock.$set(renderblock_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(renderblock.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(renderblock.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(first);
      }
      destroy_component(renderblock, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_each_block_13.name,
    type: "each",
    source: '(67:4) {#each blocks as block (\\"render-block-\\" + block.id)}',
    ctx
  });
  return block_1;
}
function create_if_block6(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like_dev(
    /*blocks*/
    ctx[0]
  );
  const get_key = (ctx2) => "block-style-" + /*block*/
  ctx2[10].id;
  validate_each_keys(ctx, each_value, get_each_context3, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context3(ctx, each_value, i);
    let key2 = get_key(child_ctx);
    each_1_lookup.set(key2, each_blocks[i] = create_each_block3(key2, child_ctx));
  }
  const block_1 = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*blocks, builderContext*/
      33) {
        each_value = ensure_array_like_dev(
          /*blocks*/
          ctx2[0]
        );
        group_outros();
        validate_each_keys(ctx2, each_value, get_each_context3, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block3, each_1_anchor, get_each_context3);
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d(detaching);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_if_block6.name,
    type: "if",
    source: "(72:2) {#if blocks}",
    ctx
  });
  return block_1;
}
function create_each_block3(key_1, ctx) {
  let first;
  let blockstyles;
  let current;
  blockstyles = new block_styles_default({
    props: {
      block: (
        /*block*/
        ctx[10]
      ),
      context: (
        /*builderContext*/
        ctx[5]
      )
    },
    $$inline: true
  });
  const block_1 = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      create_component(blockstyles.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      first = empty();
      claim_component(blockstyles.$$.fragment, nodes);
      this.h();
    },
    h: function hydrate() {
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, first, anchor);
      mount_component(blockstyles, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const blockstyles_changes = {};
      if (dirty & /*blocks*/
      1)
        blockstyles_changes.block = /*block*/
        ctx[10];
      blockstyles.$set(blockstyles_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(blockstyles.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(blockstyles.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(first);
      }
      destroy_component(blockstyles, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_each_block3.name,
    type: "each",
    source: '(73:4) {#each blocks as block (\\"block-style-\\" + block.id)}',
    ctx
  });
  return block_1;
}
function create_fragment7(ctx) {
  let div;
  let t;
  let div_class_value;
  let div_dataset_value;
  let mitosis_styling_action;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*blocks*/
    ctx[0] && create_if_block_12(ctx)
  );
  let if_block1 = (
    /*blocks*/
    ctx[0] && create_if_block6(ctx)
  );
  const block_1 = {
    c: function create() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {
        class: true,
        "builder-path": true,
        "builder-parent-id": true,
        dataset: true
      });
      var div_nodes = children(div);
      if (if_block0)
        if_block0.l(div_nodes);
      t = claim_space(div_nodes);
      if (if_block1)
        if_block1.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = null_to_empty(
        /*className*/
        ctx[4]() + " div"
      ) + " svelte-jzu5nw");
      attr_dev(
        div,
        "builder-path",
        /*path*/
        ctx[2]
      );
      attr_dev(
        div,
        "builder-parent-id",
        /*parent*/
        ctx[1]
      );
      attr_dev(div, "dataset", div_dataset_value = { class: (
        /*className*/
        ctx[4]()
      ) });
      add_location(div, file4, 50, 0, 1400);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append_hydration_dev(div, t);
      if (if_block1)
        if_block1.m(div, null);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(mitosis_styling_action = mitosis_styling.call(
            null,
            div,
            /*styleProp*/
            ctx[3]
          )),
          listen_dev(
            div,
            "click",
            /*click_handler*/
            ctx[8],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[9],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*blocks*/
        ctx2[0]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*blocks*/
          1) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_12(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*blocks*/
        ctx2[0]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*blocks*/
          1) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block6(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (!current || dirty & /*className*/
      16 && div_class_value !== (div_class_value = null_to_empty(
        /*className*/
        ctx2[4]() + " div"
      ) + " svelte-jzu5nw")) {
        attr_dev(div, "class", div_class_value);
      }
      if (!current || dirty & /*path*/
      4) {
        attr_dev(
          div,
          "builder-path",
          /*path*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*parent*/
      2) {
        attr_dev(
          div,
          "builder-parent-id",
          /*parent*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*className*/
      16 && div_dataset_value !== (div_dataset_value = { class: (
        /*className*/
        ctx2[4]()
      ) })) {
        attr_dev(div, "dataset", div_dataset_value);
      }
      if (mitosis_styling_action && is_function(mitosis_styling_action.update) && dirty & /*styleProp*/
      8)
        mitosis_styling_action.update.call(
          null,
          /*styleProp*/
          ctx2[3]
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_fragment7.name,
    type: "component",
    source: "",
    ctx
  });
  return block_1;
}
function mitosis_styling(node, vars) {
  Object.entries(vars || {}).forEach(([p, v]) => {
    if (p.startsWith("--")) {
      node.style.setProperty(p, v);
    } else {
      node.style[p] = v;
    }
  });
}
function instance7($$self, $$props, $$invalidate) {
  let className;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Render_blocks", slots, []);
  let { blocks } = $$props;
  let { parent: parent2 } = $$props;
  let { path } = $$props;
  let { styleProp } = $$props;
  let builderContext = getContext(builder_context_default.key);
  function onClick() {
    var _a;
    if (isEditing() && !(blocks == null ? void 0 : blocks.length)) {
      (_a = window.parent) == null ? void 0 : _a.postMessage(
        {
          type: "builder.clickEmptyBlocks",
          data: { parentElementId: parent2, dataPath: path }
        },
        "*"
      );
    }
  }
  function onMouseEnter() {
    var _a;
    if (isEditing() && !(blocks == null ? void 0 : blocks.length)) {
      (_a = window.parent) == null ? void 0 : _a.postMessage(
        {
          type: "builder.hoverEmptyBlocks",
          data: { parentElementId: parent2, dataPath: path }
        },
        "*"
      );
    }
  }
  $$self.$$.on_mount.push(function() {
    if (blocks === void 0 && !("blocks" in $$props || $$self.$$.bound[$$self.$$.props["blocks"]])) {
      console.warn("<Render_blocks> was created without expected prop 'blocks'");
    }
    if (parent2 === void 0 && !("parent" in $$props || $$self.$$.bound[$$self.$$.props["parent"]])) {
      console.warn("<Render_blocks> was created without expected prop 'parent'");
    }
    if (path === void 0 && !("path" in $$props || $$self.$$.bound[$$self.$$.props["path"]])) {
      console.warn("<Render_blocks> was created without expected prop 'path'");
    }
    if (styleProp === void 0 && !("styleProp" in $$props || $$self.$$.bound[$$self.$$.props["styleProp"]])) {
      console.warn("<Render_blocks> was created without expected prop 'styleProp'");
    }
  });
  const writable_props = ["blocks", "parent", "path", "styleProp"];
  Object_13.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<Render_blocks> was created with unknown prop '${key2}'`);
  });
  const click_handler = (event) => {
    onClick();
  };
  const mouseenter_handler = (event) => {
    onMouseEnter();
  };
  $$self.$$set = ($$props2) => {
    if ("blocks" in $$props2)
      $$invalidate(0, blocks = $$props2.blocks);
    if ("parent" in $$props2)
      $$invalidate(1, parent2 = $$props2.parent);
    if ("path" in $$props2)
      $$invalidate(2, path = $$props2.path);
    if ("styleProp" in $$props2)
      $$invalidate(3, styleProp = $$props2.styleProp);
  };
  $$self.$capture_state = () => ({
    getContext,
    BuilderContext: builder_context_default,
    isEditing,
    BlockStyles: block_styles_default,
    RenderBlock: render_block_default,
    blocks,
    parent: parent2,
    path,
    styleProp,
    mitosis_styling,
    builderContext,
    onClick,
    onMouseEnter,
    className
  });
  $$self.$inject_state = ($$props2) => {
    if ("blocks" in $$props2)
      $$invalidate(0, blocks = $$props2.blocks);
    if ("parent" in $$props2)
      $$invalidate(1, parent2 = $$props2.parent);
    if ("path" in $$props2)
      $$invalidate(2, path = $$props2.path);
    if ("styleProp" in $$props2)
      $$invalidate(3, styleProp = $$props2.styleProp);
    if ("builderContext" in $$props2)
      $$invalidate(5, builderContext = $$props2.builderContext);
    if ("className" in $$props2)
      $$invalidate(4, className = $$props2.className);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*blocks*/
    1) {
      $:
        $$invalidate(4, className = () => {
          return "builder-blocks" + (!(blocks == null ? void 0 : blocks.length) ? " no-blocks" : "");
        });
    }
  };
  return [
    blocks,
    parent2,
    path,
    styleProp,
    className,
    builderContext,
    onClick,
    onMouseEnter,
    click_handler,
    mouseenter_handler
  ];
}
var Render_blocks = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance7,
      create_fragment7,
      safe_not_equal,
      {
        blocks: 0,
        parent: 1,
        path: 2,
        styleProp: 3
      },
      add_css2
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Render_blocks",
      options,
      id: create_fragment7.name
    });
  }
  get blocks() {
    throw new Error("<Render_blocks>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set blocks(value) {
    throw new Error("<Render_blocks>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get parent() {
    throw new Error("<Render_blocks>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set parent(value) {
    throw new Error("<Render_blocks>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get path() {
    throw new Error("<Render_blocks>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set path(value) {
    throw new Error("<Render_blocks>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get styleProp() {
    throw new Error("<Render_blocks>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set styleProp(value) {
    throw new Error("<Render_blocks>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var render_blocks_default = Render_blocks;

// node_modules/@builder.io/sdk-svelte/package/blocks/columns/columns.svelte
var { Object: Object_14 } = globals;
var file5 = "node_modules\\@builder.io\\sdk-svelte\\package\\blocks\\columns\\columns.svelte";
function add_css3(target) {
  append_styles(target, "svelte-9u6q02", ".div.svelte-9u6q02{display:flex;line-height:normal}.div-2.svelte-9u6q02{display:flex;flex-direction:column;align-items:stretch}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29sdW1ucy5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBK0pFLGtCQUFLLENBQ0gsT0FBTyxDQUFFLElBQUksQ0FDYixXQUFXLENBQUUsTUFDZixDQUNBLG9CQUFPLENBQ0wsT0FBTyxDQUFFLElBQUksQ0FDYixjQUFjLENBQUUsTUFBTSxDQUN0QixXQUFXLENBQUUsT0FDZiIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJjb2x1bW5zLnN2ZWx0ZSJdfQ== */");
}
function get_each_context4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[18] = list[i];
  child_ctx[20] = i;
  return child_ctx;
}
function create_if_block7(ctx) {
  let renderinlinedstyles;
  let current;
  renderinlinedstyles = new render_inlined_styles_default({
    props: { styles: (
      /*columnsStyles*/
      ctx[2]()
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(renderinlinedstyles.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(renderinlinedstyles.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(renderinlinedstyles, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const renderinlinedstyles_changes = {};
      if (dirty & /*columnsStyles*/
      4)
        renderinlinedstyles_changes.styles = /*columnsStyles*/
        ctx2[2]();
      renderinlinedstyles.$set(renderinlinedstyles_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(renderinlinedstyles.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(renderinlinedstyles.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(renderinlinedstyles, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block7.name,
    type: "if",
    source: '(135:2) {#if TARGET !== \\"reactNative\\"}',
    ctx
  });
  return block;
}
function create_each_block4(key_1, ctx) {
  let div;
  let renderblocks;
  let t;
  let div_dataset_value;
  let mitosis_styling_action;
  let current;
  let mounted;
  let dispose;
  renderblocks = new render_blocks_default({
    props: {
      blocks: (
        /*column*/
        ctx[18].blocks
      ),
      path: `component.options.columns.${/*index*/
      ctx[20]}.blocks`,
      parent: (
        /*builderBlock*/
        ctx[1].id
      ),
      styleProp: { flexGrow: "1" }
    },
    $$inline: true
  });
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      div = element("div");
      create_component(renderblocks.$$.fragment);
      t = space();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, dataset: true });
      var div_nodes = children(div);
      claim_component(renderblocks.$$.fragment, div_nodes);
      t = claim_space(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "builder-column div-2 svelte-9u6q02");
      attr_dev(div, "dataset", div_dataset_value = { "builder-block-name": "builder-column" });
      add_location(div, file5, 139, 4, 4410);
      this.first = div;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(renderblocks, div, null);
      append_hydration_dev(div, t);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(mitosis_styling_action = mitosis_styling2.call(
          null,
          div,
          /*columnCssVars*/
          ctx[4](
            /*index*/
            ctx[20]
          )
        ));
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const renderblocks_changes = {};
      if (dirty & /*columns*/
      1)
        renderblocks_changes.blocks = /*column*/
        ctx[18].blocks;
      if (dirty & /*columns*/
      1)
        renderblocks_changes.path = `component.options.columns.${/*index*/
        ctx[20]}.blocks`;
      if (dirty & /*builderBlock*/
      2)
        renderblocks_changes.parent = /*builderBlock*/
        ctx[1].id;
      renderblocks.$set(renderblocks_changes);
      if (mitosis_styling_action && is_function(mitosis_styling_action.update) && dirty & /*columns*/
      1)
        mitosis_styling_action.update.call(
          null,
          /*columnCssVars*/
          ctx[4](
            /*index*/
            ctx[20]
          )
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(renderblocks.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(renderblocks.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      destroy_component(renderblocks);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block4.name,
    type: "each",
    source: "(139:2) {#each columns as column, index (index)}",
    ctx
  });
  return block;
}
function create_fragment8(ctx) {
  let div;
  let t;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let div_class_value;
  let div_dataset_value;
  let mitosis_styling_action;
  let current;
  let mounted;
  let dispose;
  let if_block = TARGET !== "reactNative" && create_if_block7(ctx);
  let each_value = ensure_array_like_dev(
    /*columns*/
    ctx[0]
  );
  const get_key = (ctx2) => (
    /*index*/
    ctx2[20]
  );
  validate_each_keys(ctx, each_value, get_each_context4, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context4(ctx, each_value, i);
    let key2 = get_key(child_ctx);
    each_1_lookup.set(key2, each_blocks[i] = create_each_block4(key2, child_ctx));
  }
  const block = {
    c: function create() {
      div = element("div");
      if (if_block)
        if_block.c();
      t = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, dataset: true });
      var div_nodes = children(div);
      if (if_block)
        if_block.l(div_nodes);
      t = claim_space(div_nodes);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div_nodes);
      }
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = null_to_empty(`builder-columns ${/*builderBlock*/
      ctx[1].id}-breakpoints div`) + " svelte-9u6q02");
      attr_dev(div, "dataset", div_dataset_value = { "builder-block-name": "builder-columns" });
      add_location(div, file5, 127, 0, 4089);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      append_hydration_dev(div, t);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(mitosis_styling_action = mitosis_styling2.call(
          null,
          div,
          /*columnsCssVars*/
          ctx[3]()
        ));
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (TARGET !== "reactNative")
        if_block.p(ctx2, dirty);
      if (dirty & /*columnCssVars, columns, builderBlock*/
      19) {
        each_value = ensure_array_like_dev(
          /*columns*/
          ctx2[0]
        );
        group_outros();
        validate_each_keys(ctx2, each_value, get_each_context4, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block4, null, get_each_context4);
        check_outros();
      }
      if (!current || dirty & /*builderBlock*/
      2 && div_class_value !== (div_class_value = null_to_empty(`builder-columns ${/*builderBlock*/
      ctx2[1].id}-breakpoints div`) + " svelte-9u6q02")) {
        attr_dev(div, "class", div_class_value);
      }
      if (mitosis_styling_action && is_function(mitosis_styling_action.update) && dirty & /*columnsCssVars*/
      8)
        mitosis_styling_action.update.call(
          null,
          /*columnsCssVars*/
          ctx2[3]()
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (if_block)
        if_block.d();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment8.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function mitosis_styling2(node, vars) {
  Object.entries(vars || {}).forEach(([p, v]) => {
    if (p.startsWith("--")) {
      node.style.setProperty(p, v);
    } else {
      node.style[p] = v;
    }
  });
}
function instance8($$self, $$props, $$invalidate) {
  let columnsCssVars;
  let columnsStyles;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Columns", slots, []);
  let { space: space2 } = $$props;
  let { columns } = $$props;
  let { stackColumnsAt } = $$props;
  let { reverseColumnsWhenStacked } = $$props;
  let { builderBlock } = $$props;
  let builderContext = getContext(builder_context_default.key);
  function getWidth(index) {
    var _a;
    return ((_a = cols[index]) == null ? void 0 : _a.width) || 100 / cols.length;
  }
  function getColumnCssWidth(index) {
    const subtractWidth = gutterSize * (cols.length - 1) / cols.length;
    return `calc(${getWidth(index)}% - ${subtractWidth}px)`;
  }
  function getTabletStyle({ stackedStyle, desktopStyle }) {
    return stackAt === "tablet" ? stackedStyle : desktopStyle;
  }
  function getMobileStyle({ stackedStyle, desktopStyle }) {
    return stackAt === "never" ? desktopStyle : stackedStyle;
  }
  function columnCssVars(index) {
    const gutter = index === 0 ? 0 : gutterSize;
    if (TARGET === "reactNative") {
      return {
        marginLeft: stackColumnsAt === "never" ? gutter : 0
      };
    }
    const width = getColumnCssWidth(index);
    const gutterPixels = `${gutterSize}px`;
    const mobileWidth = "100%";
    const mobileMarginLeft = 0;
    return {
      width,
      "margin-left": gutterPixels,
      "--column-width-mobile": getMobileStyle({
        stackedStyle: mobileWidth,
        desktopStyle: width
      }),
      "--column-margin-left-mobile": getMobileStyle({
        stackedStyle: mobileMarginLeft,
        desktopStyle: gutterPixels
      }),
      "--column-width-tablet": getTabletStyle({
        stackedStyle: mobileWidth,
        desktopStyle: width
      }),
      "--column-margin-left-tablet": getTabletStyle({
        stackedStyle: mobileMarginLeft,
        desktopStyle: gutterPixels
      })
    };
  }
  function getWidthForBreakpointSize(size) {
    var _a, _b;
    const breakpointSizes = getSizesForBreakpoints(((_b = (_a = builderContext.content) == null ? void 0 : _a.meta) == null ? void 0 : _b.breakpoints) || {});
    return breakpointSizes[size].max;
  }
  let gutterSize = typeof space2 === "number" ? space2 || 0 : 20;
  let cols = columns || [];
  let stackAt = stackColumnsAt || "tablet";
  let flexDir = stackColumnsAt === "never" ? "row" : reverseColumnsWhenStacked ? "column-reverse" : "column";
  $$self.$$.on_mount.push(function() {
    if (space2 === void 0 && !("space" in $$props || $$self.$$.bound[$$self.$$.props["space"]])) {
      console.warn("<Columns> was created without expected prop 'space'");
    }
    if (columns === void 0 && !("columns" in $$props || $$self.$$.bound[$$self.$$.props["columns"]])) {
      console.warn("<Columns> was created without expected prop 'columns'");
    }
    if (stackColumnsAt === void 0 && !("stackColumnsAt" in $$props || $$self.$$.bound[$$self.$$.props["stackColumnsAt"]])) {
      console.warn("<Columns> was created without expected prop 'stackColumnsAt'");
    }
    if (reverseColumnsWhenStacked === void 0 && !("reverseColumnsWhenStacked" in $$props || $$self.$$.bound[$$self.$$.props["reverseColumnsWhenStacked"]])) {
      console.warn("<Columns> was created without expected prop 'reverseColumnsWhenStacked'");
    }
    if (builderBlock === void 0 && !("builderBlock" in $$props || $$self.$$.bound[$$self.$$.props["builderBlock"]])) {
      console.warn("<Columns> was created without expected prop 'builderBlock'");
    }
  });
  const writable_props = [
    "space",
    "columns",
    "stackColumnsAt",
    "reverseColumnsWhenStacked",
    "builderBlock"
  ];
  Object_14.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<Columns> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("space" in $$props2)
      $$invalidate(5, space2 = $$props2.space);
    if ("columns" in $$props2)
      $$invalidate(0, columns = $$props2.columns);
    if ("stackColumnsAt" in $$props2)
      $$invalidate(6, stackColumnsAt = $$props2.stackColumnsAt);
    if ("reverseColumnsWhenStacked" in $$props2)
      $$invalidate(7, reverseColumnsWhenStacked = $$props2.reverseColumnsWhenStacked);
    if ("builderBlock" in $$props2)
      $$invalidate(1, builderBlock = $$props2.builderBlock);
  };
  $$self.$capture_state = () => ({
    getContext,
    RenderBlocks: render_blocks_default,
    getSizesForBreakpoints,
    RenderInlinedStyles: render_inlined_styles_default,
    TARGET,
    BuilderContext: builder_context_default,
    space: space2,
    columns,
    stackColumnsAt,
    reverseColumnsWhenStacked,
    builderBlock,
    mitosis_styling: mitosis_styling2,
    builderContext,
    getWidth,
    getColumnCssWidth,
    getTabletStyle,
    getMobileStyle,
    columnCssVars,
    getWidthForBreakpointSize,
    gutterSize,
    cols,
    stackAt,
    flexDir,
    columnsStyles,
    columnsCssVars
  });
  $$self.$inject_state = ($$props2) => {
    if ("space" in $$props2)
      $$invalidate(5, space2 = $$props2.space);
    if ("columns" in $$props2)
      $$invalidate(0, columns = $$props2.columns);
    if ("stackColumnsAt" in $$props2)
      $$invalidate(6, stackColumnsAt = $$props2.stackColumnsAt);
    if ("reverseColumnsWhenStacked" in $$props2)
      $$invalidate(7, reverseColumnsWhenStacked = $$props2.reverseColumnsWhenStacked);
    if ("builderBlock" in $$props2)
      $$invalidate(1, builderBlock = $$props2.builderBlock);
    if ("builderContext" in $$props2)
      builderContext = $$props2.builderContext;
    if ("gutterSize" in $$props2)
      gutterSize = $$props2.gutterSize;
    if ("cols" in $$props2)
      cols = $$props2.cols;
    if ("stackAt" in $$props2)
      stackAt = $$props2.stackAt;
    if ("flexDir" in $$props2)
      $$invalidate(17, flexDir = $$props2.flexDir);
    if ("columnsStyles" in $$props2)
      $$invalidate(2, columnsStyles = $$props2.columnsStyles);
    if ("columnsCssVars" in $$props2)
      $$invalidate(3, columnsCssVars = $$props2.columnsCssVars);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*builderBlock*/
    2) {
      $:
        $$invalidate(2, columnsStyles = () => {
          return `
      @media (max-width: ${getWidthForBreakpointSize("medium")}px) {
        .${builderBlock.id}-breakpoints {
          flex-direction: var(--flex-dir-tablet);
          align-items: stretch;
        }

        .${builderBlock.id}-breakpoints > .builder-column {
          width: var(--column-width-tablet) !important;
          margin-left: var(--column-margin-left-tablet) !important;
        }
      }

      @media (max-width: ${getWidthForBreakpointSize("small")}px) {
        .${builderBlock.id}-breakpoints {
          flex-direction: var(--flex-dir);
          align-items: stretch;
        }

        .${builderBlock.id}-breakpoints > .builder-column {
          width: var(--column-width-mobile) !important;
          margin-left: var(--column-margin-left-mobile) !important;
        }
      },
    `;
        });
    }
  };
  $:
    $$invalidate(3, columnsCssVars = () => {
      if (TARGET === "reactNative") {
        return { flexDirection: flexDir };
      }
      return {
        "--flex-dir": flexDir,
        "--flex-dir-tablet": getTabletStyle({
          stackedStyle: flexDir,
          desktopStyle: "row"
        })
      };
    });
  return [
    columns,
    builderBlock,
    columnsStyles,
    columnsCssVars,
    columnCssVars,
    space2,
    stackColumnsAt,
    reverseColumnsWhenStacked
  ];
}
var Columns = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance8,
      create_fragment8,
      safe_not_equal,
      {
        space: 5,
        columns: 0,
        stackColumnsAt: 6,
        reverseColumnsWhenStacked: 7,
        builderBlock: 1
      },
      add_css3
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Columns",
      options,
      id: create_fragment8.name
    });
  }
  get space() {
    throw new Error("<Columns>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set space(value) {
    throw new Error("<Columns>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get columns() {
    throw new Error("<Columns>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set columns(value) {
    throw new Error("<Columns>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get stackColumnsAt() {
    throw new Error("<Columns>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set stackColumnsAt(value) {
    throw new Error("<Columns>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get reverseColumnsWhenStacked() {
    throw new Error("<Columns>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set reverseColumnsWhenStacked(value) {
    throw new Error("<Columns>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get builderBlock() {
    throw new Error("<Columns>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set builderBlock(value) {
    throw new Error("<Columns>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var columns_default = Columns;

// node_modules/@builder.io/sdk-svelte/package/blocks/fragment/fragment.svelte
var file6 = "node_modules\\@builder.io\\sdk-svelte\\package\\blocks\\fragment\\fragment.svelte";
function create_fragment9(ctx) {
  let span;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  const block = {
    c: function create() {
      span = element("span");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {});
      var span_nodes = children(span);
      if (default_slot)
        default_slot.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(span, file6, 4, 0, 55);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment9.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance9($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Fragment", slots, ["default"]);
  const writable_props = [];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<Fragment> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
var Fragment = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance9, create_fragment9, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Fragment",
      options,
      id: create_fragment9.name
    });
  }
};
var fragment_default = Fragment;

// node_modules/@builder.io/sdk-svelte/package/blocks/image/image.helpers.js
function removeProtocol(path) {
  return path.replace(/http(s)?:/, "");
}
function updateQueryParam(uri = "", key2, value) {
  const re = new RegExp("([?&])" + key2 + "=.*?(&|$)", "i");
  const separator = uri.indexOf("?") !== -1 ? "&" : "?";
  if (uri.match(re)) {
    return uri.replace(re, "$1" + key2 + "=" + encodeURIComponent(value) + "$2");
  }
  return uri + separator + key2 + "=" + encodeURIComponent(value);
}
function getShopifyImageUrl(src, size) {
  if (!src || !(src == null ? void 0 : src.match(/cdn\.shopify\.com/)) || !size) {
    return src;
  }
  if (size === "master") {
    return removeProtocol(src);
  }
  const match = src.match(/(_\d+x(\d+)?)?(\.(jpg|jpeg|gif|png|bmp|bitmap|tiff|tif)(\?v=\d+)?)/i);
  if (match) {
    const prefix = src.split(match[0]);
    const suffix = match[3];
    const useSize = size.match("x") ? size : `${size}x`;
    return removeProtocol(`${prefix[0]}_${useSize}${suffix}`);
  }
  return null;
}
function getSrcSet(url) {
  if (!url) {
    return url;
  }
  const sizes = [100, 200, 400, 800, 1200, 1600, 2e3];
  if (url.match(/builder\.io/)) {
    let srcUrl = url;
    const widthInSrc = Number(url.split("?width=")[1]);
    if (!isNaN(widthInSrc)) {
      srcUrl = `${srcUrl} ${widthInSrc}w`;
    }
    return sizes.filter((size) => size !== widthInSrc).map((size) => `${updateQueryParam(url, "width", size)} ${size}w`).concat([srcUrl]).join(", ");
  }
  if (url.match(/cdn\.shopify\.com/)) {
    return sizes.map((size) => [getShopifyImageUrl(url, `${size}x${size}`), size]).filter(([sizeUrl]) => !!sizeUrl).map(([sizeUrl, size]) => `${sizeUrl} ${size}w`).concat([url]).join(", ");
  }
  return url;
}

// node_modules/@builder.io/sdk-svelte/package/blocks/image/image.svelte
var { Object: Object_15, console: console_12 } = globals;
var file7 = "node_modules\\@builder.io\\sdk-svelte\\package\\blocks\\image\\image.svelte";
function add_css4(target) {
  append_styles(target, "svelte-1udbavg", ".img.svelte-1udbavg{opacity:1;transition:opacity 0.2s ease-in-out}.div.svelte-1udbavg{width:100%;pointer-events:none;font-size:0}.div-2.svelte-1udbavg{display:flex;flex-direction:column;align-items:stretch;position:absolute;top:0;left:0;width:100%;height:100%}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW1hZ2Uuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQTJHRSxtQkFBSyxDQUNILE9BQU8sQ0FBRSxDQUFDLENBQ1YsVUFBVSxDQUFFLE9BQU8sQ0FBQyxJQUFJLENBQUMsV0FDM0IsQ0FDQSxtQkFBSyxDQUNILEtBQUssQ0FBRSxJQUFJLENBQ1gsY0FBYyxDQUFFLElBQUksQ0FDcEIsU0FBUyxDQUFFLENBQ2IsQ0FDQSxxQkFBTyxDQUNMLE9BQU8sQ0FBRSxJQUFJLENBQ2IsY0FBYyxDQUFFLE1BQU0sQ0FDdEIsV0FBVyxDQUFFLE9BQU8sQ0FDcEIsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsR0FBRyxDQUFFLENBQUMsQ0FDTixJQUFJLENBQUUsQ0FBQyxDQUNQLEtBQUssQ0FBRSxJQUFJLENBQ1gsTUFBTSxDQUFFLElBQ1YiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiaW1hZ2Uuc3ZlbHRlIl19 */");
}
function create_if_block_32(ctx) {
  let source;
  let source_srcset_value;
  const block = {
    c: function create() {
      source = element("source");
      this.h();
    },
    l: function claim(nodes) {
      source = claim_element(nodes, "SOURCE", { type: true, srcset: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(source, "type", "image/webp");
      if (!srcset_url_equal(source, source_srcset_value = /*webpSrcSet*/
      ctx[11]()))
        attr_dev(source, "srcset", source_srcset_value);
      add_location(source, file7, 69, 4, 1794);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, source, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*webpSrcSet*/
      2048 && source_srcset_value !== (source_srcset_value = /*webpSrcSet*/
      ctx2[11]())) {
        attr_dev(source, "srcset", source_srcset_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(source);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_32.name,
    type: "if",
    source: "(69:2) {#if webpSrcSet()}",
    ctx
  });
  return block;
}
function create_if_block_22(ctx) {
  let div;
  let mitosis_styling_action;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "builder-image-sizer div svelte-1udbavg");
      add_location(div, file7, 88, 2, 2321);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (!mounted) {
        dispose = action_destroyer(mitosis_styling_action = mitosis_styling3.call(null, div, {
          paddingTop: (
            /*aspectRatio*/
            ctx[1] * 100 + "%"
          )
        }));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (mitosis_styling_action && is_function(mitosis_styling_action.update) && dirty & /*aspectRatio*/
      2)
        mitosis_styling_action.update.call(null, {
          paddingTop: (
            /*aspectRatio*/
            ctx2[1] * 100 + "%"
          )
        });
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_22.name,
    type: "if",
    source: "(88:0) {#if aspectRatio && !(builderBlock?.children?.length && fitContent)}",
    ctx
  });
  return block;
}
function create_if_block_13(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        65536)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_13.name,
    type: "if",
    source: "(97:0) {#if builderBlock?.children?.length && fitContent}",
    ctx
  });
  return block;
}
function create_if_block8(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "div-2 svelte-1udbavg");
      add_location(div, file7, 101, 2, 2559);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        65536)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block8.name,
    type: "if",
    source: "(101:0) {#if !fitContent && $$slots.default}",
    ctx
  });
  return block;
}
function create_fragment10(ctx) {
  var _a, _b, _c, _d;
  let picture;
  let show_if = (
    /*webpSrcSet*/
    ctx[11]()
  );
  let t0;
  let img;
  let img_role_value;
  let img_class_value;
  let img_src_value;
  let img_srcset_value;
  let mitosis_styling_action;
  let t1;
  let t2;
  let t3;
  let if_block3_anchor;
  let current;
  let mounted;
  let dispose;
  let if_block0 = show_if && create_if_block_32(ctx);
  let if_block1 = (
    /*aspectRatio*/
    ctx[1] && !/*builderBlock*/
    (((_b = (_a = ctx[7]) == null ? void 0 : _a.children) == null ? void 0 : _b.length) && /*fitContent*/
    ctx[8]) && create_if_block_22(ctx)
  );
  let if_block2 = (
    /*builderBlock*/
    ((_d = (_c = ctx[7]) == null ? void 0 : _c.children) == null ? void 0 : _d.length) && /*fitContent*/
    ctx[8] && create_if_block_13(ctx)
  );
  let if_block3 = !/*fitContent*/
  ctx[8] && /*$$slots*/
  ctx[12].default && create_if_block8(ctx);
  const block = {
    c: function create() {
      picture = element("picture");
      if (if_block0)
        if_block0.c();
      t0 = space();
      img = element("img");
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (if_block2)
        if_block2.c();
      t3 = space();
      if (if_block3)
        if_block3.c();
      if_block3_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      picture = claim_element(nodes, "PICTURE", {});
      var picture_nodes = children(picture);
      if (if_block0)
        if_block0.l(picture_nodes);
      t0 = claim_space(picture_nodes);
      img = claim_element(picture_nodes, "IMG", {
        loading: true,
        alt: true,
        role: true,
        class: true,
        src: true,
        srcset: true,
        sizes: true
      });
      picture_nodes.forEach(detach_dev);
      t1 = claim_space(nodes);
      if (if_block1)
        if_block1.l(nodes);
      t2 = claim_space(nodes);
      if (if_block2)
        if_block2.l(nodes);
      t3 = claim_space(nodes);
      if (if_block3)
        if_block3.l(nodes);
      if_block3_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      attr_dev(img, "loading", "lazy");
      attr_dev(
        img,
        "alt",
        /*altText*/
        ctx[2]
      );
      attr_dev(img, "role", img_role_value = /*altText*/
      ctx[2] ? "presentation" : void 0);
      attr_dev(img, "class", img_class_value = null_to_empty("builder-image" + /*className*/
      (ctx[5] ? " " + /*className*/
      ctx[5] : "") + " img") + " svelte-1udbavg");
      if (!src_url_equal(img.src, img_src_value = /*image*/
      ctx[0]))
        attr_dev(img, "src", img_src_value);
      if (!srcset_url_equal(img, img_srcset_value = /*srcSetToUse*/
      ctx[9]()))
        attr_dev(img, "srcset", img_srcset_value);
      attr_dev(
        img,
        "sizes",
        /*sizes*/
        ctx[6]
      );
      add_location(img, file7, 71, 2, 1855);
      add_location(picture, file7, 67, 0, 1759);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, picture, anchor);
      if (if_block0)
        if_block0.m(picture, null);
      append_hydration_dev(picture, t0);
      append_hydration_dev(picture, img);
      insert_hydration_dev(target, t1, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_hydration_dev(target, t2, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert_hydration_dev(target, t3, anchor);
      if (if_block3)
        if_block3.m(target, anchor);
      insert_hydration_dev(target, if_block3_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(mitosis_styling_action = mitosis_styling3.call(null, img, {
          objectPosition: (
            /*backgroundPosition*/
            ctx[3] || "center"
          ),
          objectFit: (
            /*backgroundSize*/
            ctx[4] || "cover"
          ),
          .../*aspectRatioCss*/
          ctx[10]()
        }));
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      var _a2, _b2, _c2, _d2;
      if (dirty & /*webpSrcSet*/
      2048)
        show_if = /*webpSrcSet*/
        ctx2[11]();
      if (show_if) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_32(ctx2);
          if_block0.c();
          if_block0.m(picture, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (!current || dirty & /*altText*/
      4) {
        attr_dev(
          img,
          "alt",
          /*altText*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*altText*/
      4 && img_role_value !== (img_role_value = /*altText*/
      ctx2[2] ? "presentation" : void 0)) {
        attr_dev(img, "role", img_role_value);
      }
      if (!current || dirty & /*className*/
      32 && img_class_value !== (img_class_value = null_to_empty("builder-image" + /*className*/
      (ctx2[5] ? " " + /*className*/
      ctx2[5] : "") + " img") + " svelte-1udbavg")) {
        attr_dev(img, "class", img_class_value);
      }
      if (!current || dirty & /*image*/
      1 && !src_url_equal(img.src, img_src_value = /*image*/
      ctx2[0])) {
        attr_dev(img, "src", img_src_value);
      }
      if (!current || dirty & /*srcSetToUse*/
      512 && img_srcset_value !== (img_srcset_value = /*srcSetToUse*/
      ctx2[9]())) {
        attr_dev(img, "srcset", img_srcset_value);
      }
      if (!current || dirty & /*sizes*/
      64) {
        attr_dev(
          img,
          "sizes",
          /*sizes*/
          ctx2[6]
        );
      }
      if (mitosis_styling_action && is_function(mitosis_styling_action.update) && dirty & /*backgroundPosition, backgroundSize, aspectRatioCss*/
      1048)
        mitosis_styling_action.update.call(null, {
          objectPosition: (
            /*backgroundPosition*/
            ctx2[3] || "center"
          ),
          objectFit: (
            /*backgroundSize*/
            ctx2[4] || "cover"
          ),
          .../*aspectRatioCss*/
          ctx2[10]()
        });
      if (
        /*aspectRatio*/
        ctx2[1] && !/*builderBlock*/
        (((_b2 = (_a2 = ctx2[7]) == null ? void 0 : _a2.children) == null ? void 0 : _b2.length) && /*fitContent*/
        ctx2[8])
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_22(ctx2);
          if_block1.c();
          if_block1.m(t2.parentNode, t2);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (
        /*builderBlock*/
        ((_d2 = (_c2 = ctx2[7]) == null ? void 0 : _c2.children) == null ? void 0 : _d2.length) && /*fitContent*/
        ctx2[8]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & /*builderBlock, fitContent*/
          384) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_13(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(t3.parentNode, t3);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (!/*fitContent*/
      ctx2[8] && /*$$slots*/
      ctx2[12].default) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty & /*fitContent, $$slots*/
          4352) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block8(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(if_block3_anchor.parentNode, if_block3_anchor);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block2);
      transition_in(if_block3);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block2);
      transition_out(if_block3);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(picture);
        detach_dev(t1);
        detach_dev(t2);
        detach_dev(t3);
        detach_dev(if_block3_anchor);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d(detaching);
      if (if_block2)
        if_block2.d(detaching);
      if (if_block3)
        if_block3.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment10.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function mitosis_styling3(node, vars) {
  Object.entries(vars || {}).forEach(([p, v]) => {
    if (p.startsWith("--")) {
      node.style.setProperty(p, v);
    } else {
      node.style[p] = v;
    }
  });
}
function instance10($$self, $$props, $$invalidate) {
  let srcSetToUse;
  let webpSrcSet;
  let aspectRatioCss;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Image", slots, ["default"]);
  const $$slots = compute_slots(slots);
  let { image } = $$props;
  let { src } = $$props;
  let { srcset } = $$props;
  let { noWebp } = $$props;
  let { aspectRatio } = $$props;
  let { altText } = $$props;
  let { backgroundPosition } = $$props;
  let { backgroundSize } = $$props;
  let { className } = $$props;
  let { sizes } = $$props;
  let { builderBlock } = $$props;
  let { fitContent } = $$props;
  $$self.$$.on_mount.push(function() {
    if (image === void 0 && !("image" in $$props || $$self.$$.bound[$$self.$$.props["image"]])) {
      console_12.warn("<Image> was created without expected prop 'image'");
    }
    if (src === void 0 && !("src" in $$props || $$self.$$.bound[$$self.$$.props["src"]])) {
      console_12.warn("<Image> was created without expected prop 'src'");
    }
    if (srcset === void 0 && !("srcset" in $$props || $$self.$$.bound[$$self.$$.props["srcset"]])) {
      console_12.warn("<Image> was created without expected prop 'srcset'");
    }
    if (noWebp === void 0 && !("noWebp" in $$props || $$self.$$.bound[$$self.$$.props["noWebp"]])) {
      console_12.warn("<Image> was created without expected prop 'noWebp'");
    }
    if (aspectRatio === void 0 && !("aspectRatio" in $$props || $$self.$$.bound[$$self.$$.props["aspectRatio"]])) {
      console_12.warn("<Image> was created without expected prop 'aspectRatio'");
    }
    if (altText === void 0 && !("altText" in $$props || $$self.$$.bound[$$self.$$.props["altText"]])) {
      console_12.warn("<Image> was created without expected prop 'altText'");
    }
    if (backgroundPosition === void 0 && !("backgroundPosition" in $$props || $$self.$$.bound[$$self.$$.props["backgroundPosition"]])) {
      console_12.warn("<Image> was created without expected prop 'backgroundPosition'");
    }
    if (backgroundSize === void 0 && !("backgroundSize" in $$props || $$self.$$.bound[$$self.$$.props["backgroundSize"]])) {
      console_12.warn("<Image> was created without expected prop 'backgroundSize'");
    }
    if (className === void 0 && !("className" in $$props || $$self.$$.bound[$$self.$$.props["className"]])) {
      console_12.warn("<Image> was created without expected prop 'className'");
    }
    if (sizes === void 0 && !("sizes" in $$props || $$self.$$.bound[$$self.$$.props["sizes"]])) {
      console_12.warn("<Image> was created without expected prop 'sizes'");
    }
    if (builderBlock === void 0 && !("builderBlock" in $$props || $$self.$$.bound[$$self.$$.props["builderBlock"]])) {
      console_12.warn("<Image> was created without expected prop 'builderBlock'");
    }
    if (fitContent === void 0 && !("fitContent" in $$props || $$self.$$.bound[$$self.$$.props["fitContent"]])) {
      console_12.warn("<Image> was created without expected prop 'fitContent'");
    }
  });
  const writable_props = [
    "image",
    "src",
    "srcset",
    "noWebp",
    "aspectRatio",
    "altText",
    "backgroundPosition",
    "backgroundSize",
    "className",
    "sizes",
    "builderBlock",
    "fitContent"
  ];
  Object_15.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console_12.warn(`<Image> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("image" in $$props2)
      $$invalidate(0, image = $$props2.image);
    if ("src" in $$props2)
      $$invalidate(13, src = $$props2.src);
    if ("srcset" in $$props2)
      $$invalidate(14, srcset = $$props2.srcset);
    if ("noWebp" in $$props2)
      $$invalidate(15, noWebp = $$props2.noWebp);
    if ("aspectRatio" in $$props2)
      $$invalidate(1, aspectRatio = $$props2.aspectRatio);
    if ("altText" in $$props2)
      $$invalidate(2, altText = $$props2.altText);
    if ("backgroundPosition" in $$props2)
      $$invalidate(3, backgroundPosition = $$props2.backgroundPosition);
    if ("backgroundSize" in $$props2)
      $$invalidate(4, backgroundSize = $$props2.backgroundSize);
    if ("className" in $$props2)
      $$invalidate(5, className = $$props2.className);
    if ("sizes" in $$props2)
      $$invalidate(6, sizes = $$props2.sizes);
    if ("builderBlock" in $$props2)
      $$invalidate(7, builderBlock = $$props2.builderBlock);
    if ("fitContent" in $$props2)
      $$invalidate(8, fitContent = $$props2.fitContent);
    if ("$$scope" in $$props2)
      $$invalidate(16, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    getSrcSet,
    image,
    src,
    srcset,
    noWebp,
    aspectRatio,
    altText,
    backgroundPosition,
    backgroundSize,
    className,
    sizes,
    builderBlock,
    fitContent,
    mitosis_styling: mitosis_styling3,
    aspectRatioCss,
    srcSetToUse,
    webpSrcSet
  });
  $$self.$inject_state = ($$props2) => {
    if ("image" in $$props2)
      $$invalidate(0, image = $$props2.image);
    if ("src" in $$props2)
      $$invalidate(13, src = $$props2.src);
    if ("srcset" in $$props2)
      $$invalidate(14, srcset = $$props2.srcset);
    if ("noWebp" in $$props2)
      $$invalidate(15, noWebp = $$props2.noWebp);
    if ("aspectRatio" in $$props2)
      $$invalidate(1, aspectRatio = $$props2.aspectRatio);
    if ("altText" in $$props2)
      $$invalidate(2, altText = $$props2.altText);
    if ("backgroundPosition" in $$props2)
      $$invalidate(3, backgroundPosition = $$props2.backgroundPosition);
    if ("backgroundSize" in $$props2)
      $$invalidate(4, backgroundSize = $$props2.backgroundSize);
    if ("className" in $$props2)
      $$invalidate(5, className = $$props2.className);
    if ("sizes" in $$props2)
      $$invalidate(6, sizes = $$props2.sizes);
    if ("builderBlock" in $$props2)
      $$invalidate(7, builderBlock = $$props2.builderBlock);
    if ("fitContent" in $$props2)
      $$invalidate(8, fitContent = $$props2.fitContent);
    if ("aspectRatioCss" in $$props2)
      $$invalidate(10, aspectRatioCss = $$props2.aspectRatioCss);
    if ("srcSetToUse" in $$props2)
      $$invalidate(9, srcSetToUse = $$props2.srcSetToUse);
    if ("webpSrcSet" in $$props2)
      $$invalidate(11, webpSrcSet = $$props2.webpSrcSet);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*image, src, srcset*/
    24577) {
      $:
        $$invalidate(9, srcSetToUse = () => {
          const imageToUse = image || src;
          const url = imageToUse;
          if (!url || // We can auto add srcset for cdn.builder.io and shopify
          // images, otherwise you can supply this prop manually
          !(url.match(/builder\.io/) || url.match(/cdn\.shopify\.com/))) {
            return srcset;
          }
          if (srcset && (image == null ? void 0 : image.includes("builder.io/api/v1/image"))) {
            if (!srcset.includes(image.split("?")[0])) {
              console.debug("Removed given srcset");
              return getSrcSet(url);
            }
          } else if (image && !srcset) {
            return getSrcSet(url);
          }
          return getSrcSet(url);
        });
    }
    if ($$self.$$.dirty & /*srcSetToUse, noWebp*/
    33280) {
      $:
        $$invalidate(11, webpSrcSet = () => {
          var _a;
          if (((_a = srcSetToUse == null ? void 0 : srcSetToUse()) == null ? void 0 : _a.match(/builder\.io/)) && !noWebp) {
            return srcSetToUse().replace(/\?/g, "?format=webp&");
          } else {
            return "";
          }
        });
    }
    if ($$self.$$.dirty & /*aspectRatio*/
    2) {
      $:
        $$invalidate(10, aspectRatioCss = () => {
          const aspectRatioStyles = {
            position: "absolute",
            height: "100%",
            width: "100%",
            left: "0px",
            top: "0px"
          };
          const out = aspectRatio ? aspectRatioStyles : void 0;
          return out;
        });
    }
  };
  return [
    image,
    aspectRatio,
    altText,
    backgroundPosition,
    backgroundSize,
    className,
    sizes,
    builderBlock,
    fitContent,
    srcSetToUse,
    aspectRatioCss,
    webpSrcSet,
    $$slots,
    src,
    srcset,
    noWebp,
    $$scope,
    slots
  ];
}
var Image = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance10,
      create_fragment10,
      safe_not_equal,
      {
        image: 0,
        src: 13,
        srcset: 14,
        noWebp: 15,
        aspectRatio: 1,
        altText: 2,
        backgroundPosition: 3,
        backgroundSize: 4,
        className: 5,
        sizes: 6,
        builderBlock: 7,
        fitContent: 8
      },
      add_css4
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Image",
      options,
      id: create_fragment10.name
    });
  }
  get image() {
    throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set image(value) {
    throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get src() {
    throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set src(value) {
    throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get srcset() {
    throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set srcset(value) {
    throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noWebp() {
    throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noWebp(value) {
    throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get aspectRatio() {
    throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set aspectRatio(value) {
    throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get altText() {
    throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set altText(value) {
    throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get backgroundPosition() {
    throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set backgroundPosition(value) {
    throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get backgroundSize() {
    throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set backgroundSize(value) {
    throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get className() {
    throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set className(value) {
    throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sizes() {
    throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sizes(value) {
    throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get builderBlock() {
    throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set builderBlock(value) {
    throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fitContent() {
    throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fitContent(value) {
    throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var image_default = Image;

// node_modules/@builder.io/sdk-svelte/package/blocks/button/component-info.js
var componentInfo = {
  name: "Core:Button",
  image: "https://cdn.builder.io/api/v1/image/assets%2FIsxPKMo2gPRRKeakUztj1D6uqed2%2F81a15681c3e74df09677dfc57a615b13",
  defaultStyles: {
    // TODO: make min width more intuitive and set one
    appearance: "none",
    paddingTop: "15px",
    paddingBottom: "15px",
    paddingLeft: "25px",
    paddingRight: "25px",
    backgroundColor: "#000000",
    color: "white",
    borderRadius: "4px",
    textAlign: "center",
    cursor: "pointer"
  },
  inputs: [
    {
      name: "text",
      type: "text",
      defaultValue: "Click me!",
      bubble: true
    },
    {
      name: "link",
      type: "url",
      bubble: true
    },
    {
      name: "openLinkInNewTab",
      type: "boolean",
      defaultValue: false,
      friendlyName: "Open link in new tab"
    }
  ],
  static: true,
  noWrap: true
};

// node_modules/@builder.io/sdk-svelte/package/blocks/util.js
var serializeFn = (fnValue) => {
  const fnStr = fnValue.toString().trim();
  const appendFunction = !fnStr.startsWith("function") && !fnStr.startsWith("(");
  return `return (${appendFunction ? "function " : ""}${fnStr}).apply(this, arguments)`;
};

// node_modules/@builder.io/sdk-svelte/package/blocks/columns/component-info.js
var componentInfo2 = {
  // TODO: ways to statically preprocess JSON for references, functions, etc
  name: "Columns",
  inputs: [
    {
      name: "columns",
      type: "array",
      broadcast: true,
      subFields: [
        {
          name: "blocks",
          type: "array",
          hideFromUI: true,
          defaultValue: [
            {
              "@type": "@builder.io/sdk:Element",
              responsiveStyles: {
                large: {
                  display: "flex",
                  flexDirection: "column",
                  alignItems: "stretch",
                  flexShrink: "0",
                  position: "relative",
                  marginTop: "30px",
                  textAlign: "center",
                  lineHeight: "normal",
                  height: "auto",
                  minHeight: "20px",
                  minWidth: "20px",
                  overflow: "hidden"
                }
              },
              component: {
                name: "Image",
                options: {
                  image: "https://builder.io/api/v1/image/assets%2Fpwgjf0RoYWbdnJSbpBAjXNRMe9F2%2Ffb27a7c790324294af8be1c35fe30f4d",
                  backgroundPosition: "center",
                  backgroundSize: "cover",
                  aspectRatio: 0.7004048582995948
                }
              }
            },
            {
              "@type": "@builder.io/sdk:Element",
              responsiveStyles: {
                large: {
                  display: "flex",
                  flexDirection: "column",
                  alignItems: "stretch",
                  flexShrink: "0",
                  position: "relative",
                  marginTop: "30px",
                  textAlign: "center",
                  lineHeight: "normal",
                  height: "auto"
                }
              },
              component: {
                name: "Text",
                options: {
                  text: "<p>Enter some text...</p>"
                }
              }
            }
          ]
        },
        {
          name: "width",
          type: "number",
          hideFromUI: true,
          helperText: "Width %, e.g. set to 50 to fill half of the space"
        },
        {
          name: "link",
          type: "url",
          helperText: "Optionally set a url that clicking this column will link to"
        }
      ],
      defaultValue: [
        {
          blocks: [
            {
              "@type": "@builder.io/sdk:Element",
              responsiveStyles: {
                large: {
                  display: "flex",
                  flexDirection: "column",
                  alignItems: "stretch",
                  flexShrink: "0",
                  position: "relative",
                  marginTop: "30px",
                  textAlign: "center",
                  lineHeight: "normal",
                  height: "auto",
                  minHeight: "20px",
                  minWidth: "20px",
                  overflow: "hidden"
                }
              },
              component: {
                name: "Image",
                options: {
                  image: "https://builder.io/api/v1/image/assets%2Fpwgjf0RoYWbdnJSbpBAjXNRMe9F2%2Ffb27a7c790324294af8be1c35fe30f4d",
                  backgroundPosition: "center",
                  backgroundSize: "cover",
                  aspectRatio: 0.7004048582995948
                }
              }
            },
            {
              "@type": "@builder.io/sdk:Element",
              responsiveStyles: {
                large: {
                  display: "flex",
                  flexDirection: "column",
                  alignItems: "stretch",
                  flexShrink: "0",
                  position: "relative",
                  marginTop: "30px",
                  textAlign: "center",
                  lineHeight: "normal",
                  height: "auto"
                }
              },
              component: {
                name: "Text",
                options: {
                  text: "<p>Enter some text...</p>"
                }
              }
            }
          ]
        },
        {
          blocks: [
            {
              "@type": "@builder.io/sdk:Element",
              responsiveStyles: {
                large: {
                  display: "flex",
                  flexDirection: "column",
                  alignItems: "stretch",
                  flexShrink: "0",
                  position: "relative",
                  marginTop: "30px",
                  textAlign: "center",
                  lineHeight: "normal",
                  height: "auto",
                  minHeight: "20px",
                  minWidth: "20px",
                  overflow: "hidden"
                }
              },
              component: {
                name: "Image",
                options: {
                  image: "https://builder.io/api/v1/image/assets%2Fpwgjf0RoYWbdnJSbpBAjXNRMe9F2%2Ffb27a7c790324294af8be1c35fe30f4d",
                  backgroundPosition: "center",
                  backgroundSize: "cover",
                  aspectRatio: 0.7004048582995948
                }
              }
            },
            {
              "@type": "@builder.io/sdk:Element",
              responsiveStyles: {
                large: {
                  display: "flex",
                  flexDirection: "column",
                  alignItems: "stretch",
                  flexShrink: "0",
                  position: "relative",
                  marginTop: "30px",
                  textAlign: "center",
                  lineHeight: "normal",
                  height: "auto"
                }
              },
              component: {
                name: "Text",
                options: {
                  text: "<p>Enter some text...</p>"
                }
              }
            }
          ]
        }
      ],
      onChange: serializeFn((options) => {
        function clearWidths() {
          columns.forEach((col) => {
            col.delete("width");
          });
        }
        const columns = options.get("columns");
        if (Array.isArray(columns)) {
          const containsColumnWithWidth = !!columns.find((col) => col.get("width"));
          if (containsColumnWithWidth) {
            const containsColumnWithoutWidth = !!columns.find((col) => !col.get("width"));
            if (containsColumnWithoutWidth) {
              clearWidths();
            } else {
              const sumWidths = columns.reduce((memo, col) => {
                return memo + col.get("width");
              }, 0);
              const widthsDontAddUp = sumWidths !== 100;
              if (widthsDontAddUp) {
                clearWidths();
              }
            }
          }
        }
      })
    },
    {
      name: "space",
      type: "number",
      defaultValue: 20,
      helperText: "Size of gap between columns",
      advanced: true
    },
    {
      name: "stackColumnsAt",
      type: "string",
      defaultValue: "tablet",
      helperText: "Convert horizontal columns to vertical at what device size",
      enum: ["tablet", "mobile", "never"],
      advanced: true
    },
    {
      name: "reverseColumnsWhenStacked",
      type: "boolean",
      defaultValue: false,
      helperText: "When stacking columns for mobile devices, reverse the ordering",
      advanced: true
    }
  ]
};

// node_modules/@builder.io/sdk-svelte/package/blocks/fragment/component-info.js
var componentInfo3 = {
  name: "Fragment",
  static: true,
  hidden: true,
  canHaveChildren: true,
  noWrap: true
};

// node_modules/@builder.io/sdk-svelte/package/blocks/image/component-info.js
var componentInfo4 = {
  name: "Image",
  static: true,
  image: "https://firebasestorage.googleapis.com/v0/b/builder-3b0a2.appspot.com/o/images%2Fbaseline-insert_photo-24px.svg?alt=media&token=4e5d0ef4-f5e8-4e57-b3a9-38d63a9b9dc4",
  defaultStyles: {
    position: "relative",
    minHeight: "20px",
    minWidth: "20px",
    overflow: "hidden"
  },
  canHaveChildren: true,
  inputs: [
    {
      name: "image",
      type: "file",
      bubble: true,
      allowedFileTypes: ["jpeg", "jpg", "png", "svg"],
      required: true,
      defaultValue: "https://cdn.builder.io/api/v1/image/assets%2FYJIGb4i01jvw0SRdL5Bt%2F72c80f114dc149019051b6852a9e3b7a",
      onChange: serializeFn((options) => {
        const DEFAULT_ASPECT_RATIO = 0.7041;
        options.delete("srcset");
        options.delete("noWebp");
        function loadImage(url, timeout = 6e4) {
          return new Promise((resolve, reject) => {
            const img = document.createElement("img");
            let loaded = false;
            img.onload = () => {
              loaded = true;
              resolve(img);
            };
            img.addEventListener("error", (event) => {
              console.warn("Image load failed", event.error);
              reject(event.error);
            });
            img.src = url;
            setTimeout(() => {
              if (!loaded) {
                reject(new Error("Image load timed out"));
              }
            }, timeout);
          });
        }
        function round2(num) {
          return Math.round(num * 1e3) / 1e3;
        }
        const value = options.get("image");
        const aspectRatio = options.get("aspectRatio");
        fetch(value).then((res) => res.blob()).then((blob) => {
          if (blob.type.includes("svg")) {
            options.set("noWebp", true);
          }
        });
        if (value && (!aspectRatio || aspectRatio === DEFAULT_ASPECT_RATIO)) {
          return loadImage(value).then((img) => {
            const possiblyUpdatedAspectRatio = options.get("aspectRatio");
            if (options.get("image") === value && (!possiblyUpdatedAspectRatio || possiblyUpdatedAspectRatio === DEFAULT_ASPECT_RATIO)) {
              if (img.width && img.height) {
                options.set("aspectRatio", round2(img.height / img.width));
                options.set("height", img.height);
                options.set("width", img.width);
              }
            }
          });
        }
      })
    },
    {
      name: "backgroundSize",
      type: "text",
      defaultValue: "cover",
      enum: [
        {
          label: "contain",
          value: "contain",
          helperText: "The image should never get cropped"
        },
        {
          label: "cover",
          value: "cover",
          helperText: "The image should fill it's box, cropping when needed"
        }
      ]
    },
    {
      name: "backgroundPosition",
      type: "text",
      defaultValue: "center",
      enum: [
        "center",
        "top",
        "left",
        "right",
        "bottom",
        "top left",
        "top right",
        "bottom left",
        "bottom right"
      ]
    },
    {
      name: "altText",
      type: "string",
      helperText: "Text to display when the user has images off"
    },
    {
      name: "height",
      type: "number",
      hideFromUI: true
    },
    {
      name: "width",
      type: "number",
      hideFromUI: true
    },
    {
      name: "sizes",
      type: "string",
      hideFromUI: true
    },
    {
      name: "srcset",
      type: "string",
      hideFromUI: true
    },
    {
      name: "lazy",
      type: "boolean",
      defaultValue: true,
      hideFromUI: true
    },
    {
      name: "fitContent",
      type: "boolean",
      helperText: "When child blocks are provided, fit to them instead of using the image's aspect ratio",
      defaultValue: true
    },
    {
      name: "aspectRatio",
      type: "number",
      helperText: "This is the ratio of height/width, e.g. set to 1.5 for a 300px wide and 200px tall photo. Set to 0 to not force the image to maintain it's aspect ratio",
      advanced: true,
      defaultValue: 0.7041
    }
  ]
};

// node_modules/@builder.io/sdk-svelte/package/blocks/section/component-info.js
var componentInfo5 = {
  name: "Core:Section",
  static: true,
  image: "https://cdn.builder.io/api/v1/image/assets%2FIsxPKMo2gPRRKeakUztj1D6uqed2%2F682efef23ace49afac61748dd305c70a",
  inputs: [
    {
      name: "maxWidth",
      type: "number",
      defaultValue: 1200
    },
    {
      name: "lazyLoad",
      type: "boolean",
      defaultValue: false,
      advanced: true,
      description: "Only render this section when in view"
    }
  ],
  defaultStyles: {
    paddingLeft: "20px",
    paddingRight: "20px",
    paddingTop: "50px",
    paddingBottom: "50px",
    marginTop: "0px",
    width: "100vw",
    marginLeft: "calc(50% - 50vw)"
  },
  canHaveChildren: true,
  defaultChildren: [
    {
      "@type": "@builder.io/sdk:Element",
      responsiveStyles: {
        large: {
          textAlign: "center"
        }
      },
      component: {
        name: "Text",
        options: {
          text: "<p><b>I am a section! My content keeps from getting too wide, so that it's easy to read even on big screens.</b></p><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur</p>"
        }
      }
    }
  ]
};

// node_modules/@builder.io/sdk-svelte/package/blocks/section/section.svelte
var { Object: Object_16 } = globals;
var file8 = "node_modules\\@builder.io\\sdk-svelte\\package\\blocks\\section\\section.svelte";
function create_fragment11(ctx) {
  let section;
  let mitosis_styling_action;
  let setAttrs_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  let section_levels = [
    /*filterAttrs*/
    ctx[4](
      /*attributes*/
      ctx[0],
      /*isNonEvent*/
      ctx[3]
    )
  ];
  let section_data = {};
  for (let i = 0; i < section_levels.length; i += 1) {
    section_data = assign(section_data, section_levels[i]);
  }
  const block = {
    c: function create() {
      section = element("section");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      section = claim_element(nodes, "SECTION", {});
      var section_nodes = children(section);
      if (default_slot)
        default_slot.l(section_nodes);
      section_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(section, section_data);
      add_location(section, file8, 43, 0, 1197);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, section, anchor);
      if (default_slot) {
        default_slot.m(section, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(mitosis_styling_action = mitosis_styling4.call(null, section, {
            width: "100%",
            alignSelf: "stretch",
            flexGrow: 1,
            boxSizing: "border-box",
            maxWidth: (
              /*maxWidth*/
              ctx[1] || 1200
            ),
            display: "flex",
            flexDirection: "column",
            alignItems: "stretch",
            marginLeft: "auto",
            marginRight: "auto"
          })),
          action_destroyer(setAttrs_action = /*setAttrs*/
          ctx[5].call(
            null,
            section,
            /*filterAttrs*/
            ctx[4](
              /*attributes*/
              ctx[0],
              /*isEvent*/
              ctx[2]
            )
          ))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(section, section_data = get_spread_update(section_levels, [
        dirty & /*attributes*/
        1 && /*filterAttrs*/
        ctx2[4](
          /*attributes*/
          ctx2[0],
          /*isNonEvent*/
          ctx2[3]
        )
      ]));
      if (mitosis_styling_action && is_function(mitosis_styling_action.update) && dirty & /*maxWidth*/
      2)
        mitosis_styling_action.update.call(null, {
          width: "100%",
          alignSelf: "stretch",
          flexGrow: 1,
          boxSizing: "border-box",
          maxWidth: (
            /*maxWidth*/
            ctx2[1] || 1200
          ),
          display: "flex",
          flexDirection: "column",
          alignItems: "stretch",
          marginLeft: "auto",
          marginRight: "auto"
        });
      if (setAttrs_action && is_function(setAttrs_action.update) && dirty & /*attributes*/
      1)
        setAttrs_action.update.call(
          null,
          /*filterAttrs*/
          ctx2[4](
            /*attributes*/
            ctx2[0],
            /*isEvent*/
            ctx2[2]
          )
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(section);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment11.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function mitosis_styling4(node, vars) {
  Object.entries(vars || {}).forEach(([p, v]) => {
    if (p.startsWith("--")) {
      node.style.setProperty(p, v);
    } else {
      node.style[p] = v;
    }
  });
}
function instance11($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Section", slots, ["default"]);
  const isEvent = (attr) => attr.startsWith("on:");
  const isNonEvent = (attr) => !attr.startsWith("on:");
  const filterAttrs = (attrs = {}, filter) => {
    const validAttr = {};
    Object.keys(attrs).forEach((attr) => {
      if (filter(attr)) {
        validAttr[attr] = attrs[attr];
      }
    });
    return validAttr;
  };
  const setAttrs = (node, attrs = {}) => {
    const attrKeys = Object.keys(attrs);
    const setup = (attr) => node.addEventListener(attr.substr(3), attrs[attr]);
    const teardown = (attr) => node.removeEventListener(attr.substr(3), attrs[attr]);
    attrKeys.map(setup);
    return {
      update(attrs2 = {}) {
        const attrKeys2 = Object.keys(attrs2);
        attrKeys2.map(teardown);
        attrKeys2.map(setup);
      },
      destroy() {
        attrKeys.map(teardown);
      }
    };
  };
  let { attributes } = $$props;
  let { maxWidth } = $$props;
  $$self.$$.on_mount.push(function() {
    if (attributes === void 0 && !("attributes" in $$props || $$self.$$.bound[$$self.$$.props["attributes"]])) {
      console.warn("<Section> was created without expected prop 'attributes'");
    }
    if (maxWidth === void 0 && !("maxWidth" in $$props || $$self.$$.bound[$$self.$$.props["maxWidth"]])) {
      console.warn("<Section> was created without expected prop 'maxWidth'");
    }
  });
  const writable_props = ["attributes", "maxWidth"];
  Object_16.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<Section> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("attributes" in $$props2)
      $$invalidate(0, attributes = $$props2.attributes);
    if ("maxWidth" in $$props2)
      $$invalidate(1, maxWidth = $$props2.maxWidth);
    if ("$$scope" in $$props2)
      $$invalidate(6, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    isEvent,
    isNonEvent,
    filterAttrs,
    setAttrs,
    attributes,
    maxWidth,
    mitosis_styling: mitosis_styling4
  });
  $$self.$inject_state = ($$props2) => {
    if ("attributes" in $$props2)
      $$invalidate(0, attributes = $$props2.attributes);
    if ("maxWidth" in $$props2)
      $$invalidate(1, maxWidth = $$props2.maxWidth);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    attributes,
    maxWidth,
    isEvent,
    isNonEvent,
    filterAttrs,
    setAttrs,
    $$scope,
    slots
  ];
}
var Section = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance11, create_fragment11, safe_not_equal, { attributes: 0, maxWidth: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Section",
      options,
      id: create_fragment11.name
    });
  }
  get attributes() {
    throw new Error("<Section>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set attributes(value) {
    throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get maxWidth() {
    throw new Error("<Section>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set maxWidth(value) {
    throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var section_default = Section;

// node_modules/@builder.io/sdk-svelte/package/blocks/symbol/component-info.js
var componentInfo6 = {
  name: "Symbol",
  noWrap: true,
  static: true,
  inputs: [
    {
      name: "symbol",
      type: "uiSymbol"
    },
    {
      name: "dataOnly",
      helperText: "Make this a data symbol that doesn't display any UI",
      type: "boolean",
      defaultValue: false,
      advanced: true,
      hideFromUI: true
    },
    {
      name: "inheritState",
      helperText: "Inherit the parent component state and data",
      type: "boolean",
      defaultValue: false,
      advanced: true
    },
    {
      name: "renderToLiquid",
      helperText: "Render this symbols contents to liquid. Turn off to fetch with javascript and use custom targeting",
      type: "boolean",
      defaultValue: false,
      advanced: true,
      hideFromUI: true
    },
    {
      name: "useChildren",
      hideFromUI: true,
      type: "boolean"
    }
  ]
};

// node_modules/@builder.io/sdk-svelte/package/functions/get-global-this.js
function getGlobalThis() {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  return globalThis;
}

// node_modules/@builder.io/sdk-svelte/package/functions/get-fetch.js
function getFetch() {
  const globalFetch = getGlobalThis().fetch;
  if (typeof globalFetch === "undefined") {
    console.warn(`Builder SDK could not find a global fetch function. Make sure you have a polyfill for fetch in your project. 
      For more information, read https://github.com/BuilderIO/this-package-uses-fetch`);
    throw new Error("Builder SDK could not find a global `fetch` function");
  }
  return globalFetch;
}
var fetch2 = getFetch();

// node_modules/@builder.io/sdk-svelte/package/helpers/url.js
var getTopLevelDomain = (host) => {
  if (host === "localhost" || host === "127.0.0.1") {
    return host;
  }
  const parts = host.split(".");
  if (parts.length > 2) {
    return parts.slice(1).join(".");
  }
  return host;
};

// node_modules/@builder.io/sdk-svelte/package/helpers/cookie.js
var getCookie = async ({ name, canTrack }) => {
  var _a;
  try {
    if (!canTrack) {
      return void 0;
    }
    return (_a = document.cookie.split("; ").find((row) => row.startsWith(`${name}=`))) == null ? void 0 : _a.split("=")[1];
  } catch (err) {
    console.debug("[COOKIE] GET error: ", err);
    return void 0;
  }
};
var stringifyCookie = (cookie) => cookie.map(([key2, value]) => value ? `${key2}=${value}` : key2).filter(checkIsDefined).join("; ");
var SECURE_CONFIG = [
  ["secure", ""],
  ["SameSite", "None"]
];
var createCookieString = ({ name, value, expires }) => {
  const secure = isBrowser() ? location.protocol === "https:" : true;
  const secureObj = secure ? SECURE_CONFIG : [[]];
  const expiresObj = expires ? [["expires", expires.toUTCString()]] : [[]];
  const cookieValue = [
    [name, value],
    ...expiresObj,
    ["path", "/"],
    ["domain", getTopLevelDomain(window.location.hostname)],
    ...secureObj
  ];
  const cookie = stringifyCookie(cookieValue);
  return cookie;
};
var setCookie = async ({ name, value, expires, canTrack }) => {
  try {
    if (!canTrack) {
      return;
    }
    const cookie = createCookieString({ name, value, expires });
    document.cookie = cookie;
  } catch (err) {
    console.warn("[COOKIE] SET error: ", err);
  }
};

// node_modules/@builder.io/sdk-svelte/package/helpers/ab-tests.js
var BUILDER_STORE_PREFIX = "builderio.variations";
var getContentTestKey = (id) => `${BUILDER_STORE_PREFIX}.${id}`;
var getContentVariationCookie = ({ contentId, canTrack }) => getCookie({ name: getContentTestKey(contentId), canTrack });
var setContentVariationCookie = ({ contentId, canTrack, value }) => setCookie({ name: getContentTestKey(contentId), value, canTrack });

// node_modules/@builder.io/sdk-svelte/package/functions/get-content/ab-testing.js
var checkIsBuilderContentWithVariations = (item) => checkIsDefined(item.id) && checkIsDefined(item.variations) && Object.keys(item.variations).length > 0;
var getRandomVariationId = ({ id, variations }) => {
  var _a;
  let n = 0;
  const random = Math.random();
  for (const id2 in variations) {
    const testRatio = (_a = variations[id2]) == null ? void 0 : _a.testRatio;
    n += testRatio;
    if (random < n) {
      return id2;
    }
  }
  return id;
};
var getTestFields = ({ item, testGroupId }) => {
  const variationValue = item.variations[testGroupId];
  if (testGroupId === item.id || // handle edge-case where `testGroupId` points to non-existing variation
  !variationValue) {
    return {
      testVariationId: item.id,
      testVariationName: "Default"
    };
  } else {
    return {
      data: variationValue.data,
      testVariationId: variationValue.id,
      testVariationName: variationValue.name || (variationValue.id === item.id ? "Default" : "")
    };
  }
};
var getContentVariation = async ({ item, canTrack }) => {
  const testGroupId = await getContentVariationCookie({
    canTrack,
    contentId: item.id
  });
  const testFields = testGroupId ? getTestFields({ item, testGroupId }) : void 0;
  if (testFields) {
    return testFields;
  } else {
    const randomVariationId = getRandomVariationId({
      variations: item.variations,
      id: item.id
    });
    setContentVariationCookie({
      contentId: item.id,
      value: randomVariationId,
      canTrack
    }).catch((err) => {
      console.error("could not store A/B test variation: ", err);
    });
    return getTestFields({ item, testGroupId: randomVariationId });
  }
};
var handleABTesting = async ({ item, canTrack }) => {
  if (!checkIsBuilderContentWithVariations(item)) {
    return;
  }
  const variationValue = await getContentVariation({ item, canTrack });
  Object.assign(item, variationValue);
};

// node_modules/@builder.io/sdk-svelte/package/helpers/flatten.js
function flatten(object, path = null, separator = ".") {
  return Object.keys(object).reduce((acc, key2) => {
    const value = object[key2];
    const newPath = [path, key2].filter(Boolean).join(separator);
    const isObject = [
      typeof value === "object",
      value !== null,
      !(Array.isArray(value) && value.length === 0)
    ].every(Boolean);
    return isObject ? { ...acc, ...flatten(value, newPath, separator) } : { ...acc, [newPath]: value };
  }, {});
}

// node_modules/@builder.io/sdk-svelte/package/functions/get-builder-search-params/index.js
var BUILDER_SEARCHPARAMS_PREFIX = "builder.";
var BUILDER_OPTIONS_PREFIX = "options.";
var convertSearchParamsToQueryObject = (searchParams) => {
  const options = {};
  searchParams.forEach((value, key2) => {
    options[key2] = value;
  });
  return options;
};
var getBuilderSearchParams = (_options) => {
  if (!_options) {
    return {};
  }
  const options = normalizeSearchParams(_options);
  const newOptions = {};
  Object.keys(options).forEach((key2) => {
    if (key2.startsWith(BUILDER_SEARCHPARAMS_PREFIX)) {
      const trimmedKey = key2.replace(BUILDER_SEARCHPARAMS_PREFIX, "").replace(BUILDER_OPTIONS_PREFIX, "");
      newOptions[trimmedKey] = options[key2];
    }
  });
  return newOptions;
};
var getBuilderSearchParamsFromWindow = () => {
  if (!isBrowser()) {
    return {};
  }
  const searchParams = new URLSearchParams(window.location.search);
  return getBuilderSearchParams(searchParams);
};
var normalizeSearchParams = (searchParams) => searchParams instanceof URLSearchParams ? convertSearchParamsToQueryObject(searchParams) : searchParams;

// node_modules/@builder.io/sdk-svelte/package/functions/get-content/generate-content-url.js
var generateContentUrl = (options) => {
  const { limit = 30, userAttributes, query, noTraverse = false, model, apiKey, includeRefs = true, locale, apiVersion = "v2" } = options;
  if (!apiKey) {
    throw new Error("Missing API key");
  }
  if (!["v2", "v3"].includes(apiVersion)) {
    throw new Error(`Invalid apiVersion: expected 'v2' or 'v3', received '${apiVersion}'`);
  }
  const url = new URL(`https://cdn.builder.io/api/${apiVersion}/content/${model}?apiKey=${apiKey}&limit=${limit}&noTraverse=${noTraverse}&includeRefs=${includeRefs}${locale ? `&locale=${locale}` : ""}`);
  const queryOptions = {
    ...getBuilderSearchParamsFromWindow(),
    ...normalizeSearchParams(options.options || {})
  };
  const flattened = flatten(queryOptions);
  for (const key2 in flattened) {
    url.searchParams.set(key2, String(flattened[key2]));
  }
  if (userAttributes) {
    url.searchParams.set("userAttributes", JSON.stringify(userAttributes));
  }
  if (query) {
    const flattened2 = flatten({ query });
    for (const key2 in flattened2) {
      url.searchParams.set(key2, JSON.stringify(flattened2[key2]));
    }
  }
  return url;
};

// node_modules/@builder.io/sdk-svelte/package/functions/get-content/index.js
async function getContent(options) {
  const allContent = await getAllContent({ ...options, limit: 1 });
  if ("results" in allContent) {
    return (allContent == null ? void 0 : allContent.results[0]) || null;
  }
  return null;
}
async function getAllContent(options) {
  const url = generateContentUrl(options);
  const res = await fetch2(url.href);
  const content = await res.json();
  if ("status" in content && !("results" in content)) {
    console.error("[Builder.io]: Error fetching data. ", content, options);
    return content;
  }
  const canTrack = options.canTrack !== false;
  try {
    if (canTrack && // This makes sure we have a non-error response with the results array.
    Array.isArray(content.results)) {
      for (const item of content.results) {
        await handleABTesting({ item, canTrack });
      }
    }
  } catch (e) {
    console.error("[Builder.io]: Could not setup A/B testing. ", e);
  }
  return content;
}

// node_modules/@builder.io/sdk-svelte/package/blocks/symbol/symbol.svelte
var { Object: Object_17, console: console_13 } = globals;
var file9 = "node_modules\\@builder.io\\sdk-svelte\\package\\blocks\\symbol\\symbol.svelte";
function create_fragment12(ctx) {
  var _a, _b, _c, _d;
  let div;
  let rendercontent;
  let div_dataset_value;
  let setAttrs_action;
  let current;
  let mounted;
  let dispose;
  rendercontent = new render_content_default({
    props: {
      apiVersion: (
        /*builderContext*/
        ctx[7].apiVersion
      ),
      apiKey: (
        /*builderContext*/
        ctx[7].apiKey
      ),
      context: (
        /*builderContext*/
        ctx[7].context
      ),
      customComponents: Object.values(
        /*builderContext*/
        ctx[7].registeredComponents
      ),
      data: {
        .../*symbol*/
        (_a = ctx[1]) == null ? void 0 : _a.data,
        .../*builderContext*/
        ctx[7].state,
        .../*contentToUse*/
        (_c = (_b = ctx[2]) == null ? void 0 : _b.data) == null ? void 0 : _c.state
      },
      model: (
        /*symbol*/
        (_d = ctx[1]) == null ? void 0 : _d.model
      ),
      content: (
        /*contentToUse*/
        ctx[2]
      )
    },
    $$inline: true
  });
  let div_levels = [
    /*filterAttrs*/
    ctx[5](
      /*attributes*/
      ctx[0],
      /*isNonEvent*/
      ctx[4]
    ),
    {
      dataset: div_dataset_value = { class: (
        /*className*/
        ctx[8]
      ) }
    },
    { class: (
      /*className*/
      ctx[8]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      create_component(rendercontent.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { dataset: true, class: true });
      var div_nodes = children(div);
      claim_component(rendercontent.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file9, 92, 0, 2837);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(rendercontent, div, null);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(setAttrs_action = /*setAttrs*/
        ctx[6].call(
          null,
          div,
          /*filterAttrs*/
          ctx[5](
            /*attributes*/
            ctx[0],
            /*isEvent*/
            ctx[3]
          )
        ));
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      var _a2, _b2, _c2, _d2;
      const rendercontent_changes = {};
      if (dirty & /*symbol, contentToUse*/
      6)
        rendercontent_changes.data = {
          .../*symbol*/
          (_a2 = ctx2[1]) == null ? void 0 : _a2.data,
          .../*builderContext*/
          ctx2[7].state,
          .../*contentToUse*/
          (_c2 = (_b2 = ctx2[2]) == null ? void 0 : _b2.data) == null ? void 0 : _c2.state
        };
      if (dirty & /*symbol*/
      2)
        rendercontent_changes.model = /*symbol*/
        (_d2 = ctx2[1]) == null ? void 0 : _d2.model;
      if (dirty & /*contentToUse*/
      4)
        rendercontent_changes.content = /*contentToUse*/
        ctx2[2];
      rendercontent.$set(rendercontent_changes);
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*attributes*/
        1 && /*filterAttrs*/
        ctx2[5](
          /*attributes*/
          ctx2[0],
          /*isNonEvent*/
          ctx2[4]
        ),
        { dataset: div_dataset_value },
        { class: (
          /*className*/
          ctx2[8]
        ) }
      ]));
      if (setAttrs_action && is_function(setAttrs_action.update) && dirty & /*attributes*/
      1)
        setAttrs_action.update.call(
          null,
          /*filterAttrs*/
          ctx2[5](
            /*attributes*/
            ctx2[0],
            /*isEvent*/
            ctx2[3]
          )
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(rendercontent.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(rendercontent.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      destroy_component(rendercontent);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment12.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance12($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Symbol", slots, []);
  const isEvent = (attr) => attr.startsWith("on:");
  const isNonEvent = (attr) => !attr.startsWith("on:");
  const filterAttrs = (attrs = {}, filter) => {
    const validAttr = {};
    Object.keys(attrs).forEach((attr) => {
      if (filter(attr)) {
        validAttr[attr] = attrs[attr];
      }
    });
    return validAttr;
  };
  const setAttrs = (node, attrs = {}) => {
    const attrKeys = Object.keys(attrs);
    const setup = (attr) => node.addEventListener(attr.substr(3), attrs[attr]);
    const teardown = (attr) => node.removeEventListener(attr.substr(3), attrs[attr]);
    attrKeys.map(setup);
    return {
      update(attrs2 = {}) {
        const attrKeys2 = Object.keys(attrs2);
        attrKeys2.map(teardown);
        attrKeys2.map(setup);
      },
      destroy() {
        attrKeys.map(teardown);
      }
    };
  };
  let { attributes } = $$props;
  let { symbol } = $$props;
  let { dynamic } = $$props;
  let builderContext = getContext(builder_context_default.key);
  function fetchContent() {
    if (!contentToUse && (symbol == null ? void 0 : symbol.model) && // This is a hack, we should not need to check for this, but it is needed for Svelte.
    (builderContext == null ? void 0 : builderContext.apiKey)) {
      getContent({
        model: symbol.model,
        apiKey: builderContext.apiKey,
        apiVersion: builderContext.apiVersion,
        query: { id: symbol.entry }
      }).then((response) => {
        if (response) {
          $$invalidate(2, contentToUse = response);
        }
      }).catch((err) => {
        console.error("[Builder.io]: Could not fetch symbol content: ", err);
      });
    }
  }
  let className = [
    ...TARGET === "vue2" || TARGET === "vue3" ? Object.keys(attributes.class) : [attributes.class],
    "builder-symbol",
    (symbol == null ? void 0 : symbol.inline) ? "builder-inline-symbol" : void 0,
    (symbol == null ? void 0 : symbol.dynamic) || dynamic ? "builder-dynamic-symbol" : void 0
  ].filter(Boolean).join(" ");
  let contentToUse = symbol == null ? void 0 : symbol.content;
  onMount(() => {
    fetchContent();
  });
  function onUpdateFn_0() {
    fetchContent();
  }
  $$self.$$.on_mount.push(function() {
    if (attributes === void 0 && !("attributes" in $$props || $$self.$$.bound[$$self.$$.props["attributes"]])) {
      console_13.warn("<Symbol> was created without expected prop 'attributes'");
    }
    if (symbol === void 0 && !("symbol" in $$props || $$self.$$.bound[$$self.$$.props["symbol"]])) {
      console_13.warn("<Symbol> was created without expected prop 'symbol'");
    }
    if (dynamic === void 0 && !("dynamic" in $$props || $$self.$$.bound[$$self.$$.props["dynamic"]])) {
      console_13.warn("<Symbol> was created without expected prop 'dynamic'");
    }
  });
  const writable_props = ["attributes", "symbol", "dynamic"];
  Object_17.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console_13.warn(`<Symbol> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("attributes" in $$props2)
      $$invalidate(0, attributes = $$props2.attributes);
    if ("symbol" in $$props2)
      $$invalidate(1, symbol = $$props2.symbol);
    if ("dynamic" in $$props2)
      $$invalidate(9, dynamic = $$props2.dynamic);
  };
  $$self.$capture_state = () => ({
    getContext,
    onMount,
    RenderContent: render_content_default,
    BuilderContext: builder_context_default,
    getContent,
    TARGET,
    isEvent,
    isNonEvent,
    filterAttrs,
    setAttrs,
    attributes,
    symbol,
    dynamic,
    builderContext,
    fetchContent,
    className,
    contentToUse,
    onUpdateFn_0
  });
  $$self.$inject_state = ($$props2) => {
    if ("attributes" in $$props2)
      $$invalidate(0, attributes = $$props2.attributes);
    if ("symbol" in $$props2)
      $$invalidate(1, symbol = $$props2.symbol);
    if ("dynamic" in $$props2)
      $$invalidate(9, dynamic = $$props2.dynamic);
    if ("builderContext" in $$props2)
      $$invalidate(7, builderContext = $$props2.builderContext);
    if ("className" in $$props2)
      $$invalidate(8, className = $$props2.className);
    if ("contentToUse" in $$props2)
      $$invalidate(2, contentToUse = $$props2.contentToUse);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*symbol*/
    2) {
      $:
        onUpdateFn_0(...[symbol]);
    }
  };
  return [
    attributes,
    symbol,
    contentToUse,
    isEvent,
    isNonEvent,
    filterAttrs,
    setAttrs,
    builderContext,
    className,
    dynamic
  ];
}
var Symbol2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance12, create_fragment12, safe_not_equal, { attributes: 0, symbol: 1, dynamic: 9 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Symbol",
      options,
      id: create_fragment12.name
    });
  }
  get attributes() {
    throw new Error("<Symbol>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set attributes(value) {
    throw new Error("<Symbol>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get symbol() {
    throw new Error("<Symbol>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set symbol(value) {
    throw new Error("<Symbol>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dynamic() {
    throw new Error("<Symbol>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dynamic(value) {
    throw new Error("<Symbol>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var symbol_default = Symbol2;

// node_modules/@builder.io/sdk-svelte/package/blocks/text/component-info.js
var componentInfo7 = {
  name: "Text",
  static: true,
  image: "https://firebasestorage.googleapis.com/v0/b/builder-3b0a2.appspot.com/o/images%2Fbaseline-text_fields-24px%20(1).svg?alt=media&token=12177b73-0ee3-42ca-98c6-0dd003de1929",
  inputs: [
    {
      name: "text",
      type: "html",
      required: true,
      autoFocus: true,
      bubble: true,
      defaultValue: "Enter some text..."
    }
  ],
  defaultStyles: {
    lineHeight: "normal",
    height: "auto",
    textAlign: "center"
  }
};

// node_modules/@builder.io/sdk-svelte/package/blocks/text/text.svelte
var { Object: Object_18 } = globals;
var file10 = "node_modules\\@builder.io\\sdk-svelte\\package\\blocks\\text\\text.svelte";
function create_fragment13(ctx) {
  let span;
  let html_tag;
  let mitosis_styling_action;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      span = element("span");
      html_tag = new HtmlTagHydration(false);
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      html_tag = claim_html_tag(span_nodes, false);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      html_tag.a = null;
      attr_dev(span, "class", "builder-text");
      add_location(span, file10, 15, 0, 316);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      html_tag.m(
        /*text*/
        ctx[0],
        span
      );
      if (!mounted) {
        dispose = action_destroyer(mitosis_styling_action = mitosis_styling5.call(null, span, { outline: "none" }));
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*text*/
      1)
        html_tag.p(
          /*text*/
          ctx2[0]
        );
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment13.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function mitosis_styling5(node, vars) {
  Object.entries(vars || {}).forEach(([p, v]) => {
    if (p.startsWith("--")) {
      node.style.setProperty(p, v);
    } else {
      node.style[p] = v;
    }
  });
}
function instance13($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Text", slots, []);
  let { text: text2 } = $$props;
  $$self.$$.on_mount.push(function() {
    if (text2 === void 0 && !("text" in $$props || $$self.$$.bound[$$self.$$.props["text"]])) {
      console.warn("<Text> was created without expected prop 'text'");
    }
  });
  const writable_props = ["text"];
  Object_18.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<Text> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("text" in $$props2)
      $$invalidate(0, text2 = $$props2.text);
  };
  $$self.$capture_state = () => ({ text: text2, mitosis_styling: mitosis_styling5 });
  $$self.$inject_state = ($$props2) => {
    if ("text" in $$props2)
      $$invalidate(0, text2 = $$props2.text);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [text2];
}
var Text = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance13, create_fragment13, safe_not_equal, { text: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Text",
      options,
      id: create_fragment13.name
    });
  }
  get text() {
    throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value) {
    throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var text_default = Text;

// node_modules/@builder.io/sdk-svelte/package/blocks/video/component-info.js
var componentInfo8 = {
  name: "Video",
  canHaveChildren: true,
  defaultStyles: {
    minHeight: "20px",
    minWidth: "20px"
  },
  image: "https://firebasestorage.googleapis.com/v0/b/builder-3b0a2.appspot.com/o/images%2Fbaseline-videocam-24px%20(1).svg?alt=media&token=49a84e4a-b20e-4977-a650-047f986874bb",
  inputs: [
    {
      name: "video",
      type: "file",
      allowedFileTypes: ["mp4"],
      bubble: true,
      defaultValue: "https://firebasestorage.googleapis.com/v0/b/builder-3b0a2.appspot.com/o/assets%2FKQlEmWDxA0coC3PK6UvkrjwkIGI2%2F28cb070609f546cdbe5efa20e931aa4b?alt=media&token=912e9551-7a7c-4dfb-86b6-3da1537d1a7f",
      required: true
    },
    {
      name: "posterImage",
      type: "file",
      allowedFileTypes: ["jpeg", "png"],
      helperText: "Image to show before the video plays"
    },
    {
      name: "autoPlay",
      type: "boolean",
      defaultValue: true
    },
    {
      name: "controls",
      type: "boolean",
      defaultValue: false
    },
    {
      name: "muted",
      type: "boolean",
      defaultValue: true
    },
    {
      name: "loop",
      type: "boolean",
      defaultValue: true
    },
    {
      name: "playsInline",
      type: "boolean",
      defaultValue: true
    },
    {
      name: "fit",
      type: "text",
      defaultValue: "cover",
      enum: ["contain", "cover", "fill", "auto"]
    },
    {
      name: "fitContent",
      type: "boolean",
      helperText: "When child blocks are provided, fit to them instead of using the aspect ratio",
      defaultValue: true,
      advanced: true
    },
    {
      name: "position",
      type: "text",
      defaultValue: "center",
      enum: [
        "center",
        "top",
        "left",
        "right",
        "bottom",
        "top left",
        "top right",
        "bottom left",
        "bottom right"
      ]
    },
    {
      name: "height",
      type: "number",
      advanced: true
    },
    {
      name: "width",
      type: "number",
      advanced: true
    },
    {
      name: "aspectRatio",
      type: "number",
      advanced: true,
      defaultValue: 0.7004048582995948
    },
    {
      name: "lazyLoad",
      type: "boolean",
      helperText: 'Load this video "lazily" - as in only when a user scrolls near the video. Recommended for optmized performance and bandwidth consumption',
      defaultValue: true,
      advanced: true
    }
  ]
};

// node_modules/@builder.io/sdk-svelte/package/blocks/video/video.svelte
var { Object: Object_19 } = globals;
var file11 = "node_modules\\@builder.io\\sdk-svelte\\package\\blocks\\video\\video.svelte";
function create_fragment14(ctx) {
  let video_1;
  let video_1_src_value;
  let mitosis_styling_action;
  let setAttrs_action;
  let mounted;
  let dispose;
  let video_1_levels = [
    /*filterAttrs*/
    ctx[8](
      /*spreadProps*/
      ctx[5](),
      /*isNonEvent*/
      ctx[7]
    ),
    {
      src: video_1_src_value = /*video*/
      ctx[3] || "no-src"
    },
    { poster: (
      /*posterImage*/
      ctx[4]
    ) }
  ];
  let video_data = {};
  for (let i = 0; i < video_1_levels.length; i += 1) {
    video_data = assign(video_data, video_1_levels[i]);
  }
  const block = {
    c: function create() {
      video_1 = element("video");
      this.h();
    },
    l: function claim(nodes) {
      video_1 = claim_element(nodes, "VIDEO", { src: true, poster: true });
      children(video_1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(video_1, video_data);
      add_location(video_1, file11, 86, 0, 2046);
    },
    m: function mount(target, anchor) {
      var _a;
      insert_hydration_dev(target, video_1, anchor);
      if (!mounted) {
        dispose = [
          action_destroyer(mitosis_styling_action = mitosis_styling6.call(null, video_1, {
            width: "100%",
            height: "100%",
            .../*attributes*/
            (_a = ctx[0]) == null ? void 0 : _a.style,
            objectFit: (
              /*fit*/
              ctx[1]
            ),
            objectPosition: (
              /*position*/
              ctx[2]
            ),
            // Hack to get object fit to work as expected and
            // not have the video overflow
            borderRadius: 1
          })),
          action_destroyer(setAttrs_action = /*setAttrs*/
          ctx[9].call(
            null,
            video_1,
            /*filterAttrs*/
            ctx[8](
              /*spreadProps*/
              ctx[5](),
              /*isEvent*/
              ctx[6]
            )
          ))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      var _a;
      set_attributes(video_1, video_data = get_spread_update(video_1_levels, [
        dirty & /*spreadProps*/
        32 && /*filterAttrs*/
        ctx2[8](
          /*spreadProps*/
          ctx2[5](),
          /*isNonEvent*/
          ctx2[7]
        ),
        dirty & /*video*/
        8 && !src_url_equal(video_1.src, video_1_src_value = /*video*/
        ctx2[3] || "no-src") && { src: video_1_src_value },
        dirty & /*posterImage*/
        16 && { poster: (
          /*posterImage*/
          ctx2[4]
        ) }
      ]));
      if (mitosis_styling_action && is_function(mitosis_styling_action.update) && dirty & /*attributes, fit, position*/
      7)
        mitosis_styling_action.update.call(null, {
          width: "100%",
          height: "100%",
          .../*attributes*/
          (_a = ctx2[0]) == null ? void 0 : _a.style,
          objectFit: (
            /*fit*/
            ctx2[1]
          ),
          objectPosition: (
            /*position*/
            ctx2[2]
          ),
          // Hack to get object fit to work as expected and
          // not have the video overflow
          borderRadius: 1
        });
      if (setAttrs_action && is_function(setAttrs_action.update) && dirty & /*spreadProps*/
      32)
        setAttrs_action.update.call(
          null,
          /*filterAttrs*/
          ctx2[8](
            /*spreadProps*/
            ctx2[5](),
            /*isEvent*/
            ctx2[6]
          )
        );
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(video_1);
      }
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment14.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function mitosis_styling6(node, vars) {
  Object.entries(vars || {}).forEach(([p, v]) => {
    if (p.startsWith("--")) {
      node.style.setProperty(p, v);
    } else {
      node.style[p] = v;
    }
  });
}
function instance14($$self, $$props, $$invalidate) {
  let videoProps;
  let spreadProps;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Video", slots, []);
  const isEvent = (attr) => attr.startsWith("on:");
  const isNonEvent = (attr) => !attr.startsWith("on:");
  const filterAttrs = (attrs = {}, filter) => {
    const validAttr = {};
    Object.keys(attrs).forEach((attr) => {
      if (filter(attr)) {
        validAttr[attr] = attrs[attr];
      }
    });
    return validAttr;
  };
  const setAttrs = (node, attrs = {}) => {
    const attrKeys = Object.keys(attrs);
    const setup = (attr) => node.addEventListener(attr.substr(3), attrs[attr]);
    const teardown = (attr) => node.removeEventListener(attr.substr(3), attrs[attr]);
    attrKeys.map(setup);
    return {
      update(attrs2 = {}) {
        const attrKeys2 = Object.keys(attrs2);
        attrKeys2.map(teardown);
        attrKeys2.map(setup);
      },
      destroy() {
        attrKeys.map(teardown);
      }
    };
  };
  let { autoPlay } = $$props;
  let { muted } = $$props;
  let { controls } = $$props;
  let { loop } = $$props;
  let { playsInline } = $$props;
  let { attributes } = $$props;
  let { fit } = $$props;
  let { position } = $$props;
  let { video } = $$props;
  let { posterImage } = $$props;
  $$self.$$.on_mount.push(function() {
    if (autoPlay === void 0 && !("autoPlay" in $$props || $$self.$$.bound[$$self.$$.props["autoPlay"]])) {
      console.warn("<Video> was created without expected prop 'autoPlay'");
    }
    if (muted === void 0 && !("muted" in $$props || $$self.$$.bound[$$self.$$.props["muted"]])) {
      console.warn("<Video> was created without expected prop 'muted'");
    }
    if (controls === void 0 && !("controls" in $$props || $$self.$$.bound[$$self.$$.props["controls"]])) {
      console.warn("<Video> was created without expected prop 'controls'");
    }
    if (loop === void 0 && !("loop" in $$props || $$self.$$.bound[$$self.$$.props["loop"]])) {
      console.warn("<Video> was created without expected prop 'loop'");
    }
    if (playsInline === void 0 && !("playsInline" in $$props || $$self.$$.bound[$$self.$$.props["playsInline"]])) {
      console.warn("<Video> was created without expected prop 'playsInline'");
    }
    if (attributes === void 0 && !("attributes" in $$props || $$self.$$.bound[$$self.$$.props["attributes"]])) {
      console.warn("<Video> was created without expected prop 'attributes'");
    }
    if (fit === void 0 && !("fit" in $$props || $$self.$$.bound[$$self.$$.props["fit"]])) {
      console.warn("<Video> was created without expected prop 'fit'");
    }
    if (position === void 0 && !("position" in $$props || $$self.$$.bound[$$self.$$.props["position"]])) {
      console.warn("<Video> was created without expected prop 'position'");
    }
    if (video === void 0 && !("video" in $$props || $$self.$$.bound[$$self.$$.props["video"]])) {
      console.warn("<Video> was created without expected prop 'video'");
    }
    if (posterImage === void 0 && !("posterImage" in $$props || $$self.$$.bound[$$self.$$.props["posterImage"]])) {
      console.warn("<Video> was created without expected prop 'posterImage'");
    }
  });
  const writable_props = [
    "autoPlay",
    "muted",
    "controls",
    "loop",
    "playsInline",
    "attributes",
    "fit",
    "position",
    "video",
    "posterImage"
  ];
  Object_19.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<Video> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("autoPlay" in $$props2)
      $$invalidate(10, autoPlay = $$props2.autoPlay);
    if ("muted" in $$props2)
      $$invalidate(11, muted = $$props2.muted);
    if ("controls" in $$props2)
      $$invalidate(12, controls = $$props2.controls);
    if ("loop" in $$props2)
      $$invalidate(13, loop = $$props2.loop);
    if ("playsInline" in $$props2)
      $$invalidate(14, playsInline = $$props2.playsInline);
    if ("attributes" in $$props2)
      $$invalidate(0, attributes = $$props2.attributes);
    if ("fit" in $$props2)
      $$invalidate(1, fit = $$props2.fit);
    if ("position" in $$props2)
      $$invalidate(2, position = $$props2.position);
    if ("video" in $$props2)
      $$invalidate(3, video = $$props2.video);
    if ("posterImage" in $$props2)
      $$invalidate(4, posterImage = $$props2.posterImage);
  };
  $$self.$capture_state = () => ({
    isEvent,
    isNonEvent,
    filterAttrs,
    setAttrs,
    autoPlay,
    muted,
    controls,
    loop,
    playsInline,
    attributes,
    fit,
    position,
    video,
    posterImage,
    mitosis_styling: mitosis_styling6,
    videoProps,
    spreadProps
  });
  $$self.$inject_state = ($$props2) => {
    if ("autoPlay" in $$props2)
      $$invalidate(10, autoPlay = $$props2.autoPlay);
    if ("muted" in $$props2)
      $$invalidate(11, muted = $$props2.muted);
    if ("controls" in $$props2)
      $$invalidate(12, controls = $$props2.controls);
    if ("loop" in $$props2)
      $$invalidate(13, loop = $$props2.loop);
    if ("playsInline" in $$props2)
      $$invalidate(14, playsInline = $$props2.playsInline);
    if ("attributes" in $$props2)
      $$invalidate(0, attributes = $$props2.attributes);
    if ("fit" in $$props2)
      $$invalidate(1, fit = $$props2.fit);
    if ("position" in $$props2)
      $$invalidate(2, position = $$props2.position);
    if ("video" in $$props2)
      $$invalidate(3, video = $$props2.video);
    if ("posterImage" in $$props2)
      $$invalidate(4, posterImage = $$props2.posterImage);
    if ("videoProps" in $$props2)
      $$invalidate(15, videoProps = $$props2.videoProps);
    if ("spreadProps" in $$props2)
      $$invalidate(5, spreadProps = $$props2.spreadProps);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*autoPlay, muted, controls, loop, playsInline*/
    31744) {
      $:
        $$invalidate(15, videoProps = () => {
          return {
            ...autoPlay === true ? { autoPlay: true } : {},
            ...muted === true ? { muted: true } : {},
            ...controls === true ? { controls: true } : {},
            ...loop === true ? { loop: true } : {},
            ...playsInline === true ? { playsInline: true } : {}
          };
        });
    }
    if ($$self.$$.dirty & /*attributes, videoProps*/
    32769) {
      $:
        $$invalidate(5, spreadProps = () => {
          return { ...attributes, ...videoProps() };
        });
    }
  };
  return [
    attributes,
    fit,
    position,
    video,
    posterImage,
    spreadProps,
    isEvent,
    isNonEvent,
    filterAttrs,
    setAttrs,
    autoPlay,
    muted,
    controls,
    loop,
    playsInline,
    videoProps
  ];
}
var Video = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance14, create_fragment14, safe_not_equal, {
      autoPlay: 10,
      muted: 11,
      controls: 12,
      loop: 13,
      playsInline: 14,
      attributes: 0,
      fit: 1,
      position: 2,
      video: 3,
      posterImage: 4
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Video",
      options,
      id: create_fragment14.name
    });
  }
  get autoPlay() {
    throw new Error("<Video>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autoPlay(value) {
    throw new Error("<Video>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get muted() {
    throw new Error("<Video>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set muted(value) {
    throw new Error("<Video>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get controls() {
    throw new Error("<Video>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set controls(value) {
    throw new Error("<Video>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get loop() {
    throw new Error("<Video>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set loop(value) {
    throw new Error("<Video>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get playsInline() {
    throw new Error("<Video>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set playsInline(value) {
    throw new Error("<Video>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get attributes() {
    throw new Error("<Video>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set attributes(value) {
    throw new Error("<Video>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fit() {
    throw new Error("<Video>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fit(value) {
    throw new Error("<Video>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get position() {
    throw new Error("<Video>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<Video>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get video() {
    throw new Error("<Video>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set video(value) {
    throw new Error("<Video>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get posterImage() {
    throw new Error("<Video>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set posterImage(value) {
    throw new Error("<Video>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var video_default = Video;

// node_modules/@builder.io/sdk-svelte/package/blocks/embed/component-info.js
var componentInfo9 = {
  name: "Embed",
  static: true,
  inputs: [
    {
      name: "url",
      type: "url",
      required: true,
      defaultValue: "",
      helperText: "e.g. enter a youtube url, google map, etc",
      onChange: serializeFn((options) => {
        const url = options.get("url");
        if (url) {
          options.set("content", "Loading...");
          const apiKey = "ae0e60e78201a3f2b0de4b";
          return fetch(`https://iframe.ly/api/iframely?url=${url}&api_key=${apiKey}`).then((res) => res.json()).then((data) => {
            if (options.get("url") === url) {
              if (data.html) {
                options.set("content", data.html);
              } else {
                options.set("content", "Invalid url, please try another");
              }
            }
          }).catch((_err) => {
            options.set("content", "There was an error embedding this URL, please try again or another URL");
          });
        } else {
          options.delete("content");
        }
      })
    },
    {
      name: "content",
      type: "html",
      defaultValue: '<div style="padding: 20px; text-align: center">(Choose an embed URL)<div>',
      hideFromUI: true
    }
  ]
};

// node_modules/@builder.io/sdk-svelte/package/blocks/embed/helpers.js
var SCRIPT_MIME_TYPES = [
  "text/javascript",
  "application/javascript",
  "application/ecmascript"
];
var isJsScript = (script) => SCRIPT_MIME_TYPES.includes(script.type);

// node_modules/@builder.io/sdk-svelte/package/blocks/embed/embed.svelte
var { console: console_14 } = globals;
var file12 = "node_modules\\@builder.io\\sdk-svelte\\package\\blocks\\embed\\embed.svelte";
function create_fragment15(ctx) {
  let div;
  let html_tag;
  const block = {
    c: function create() {
      div = element("div");
      html_tag = new HtmlTagHydration(false);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      html_tag = claim_html_tag(div_nodes, false);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      html_tag.a = null;
      attr_dev(div, "class", "builder-embed");
      add_location(div, file12, 41, 0, 1245);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      html_tag.m(
        /*content*/
        ctx[0],
        div
      );
      ctx[3](div);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*content*/
      1)
        html_tag.p(
          /*content*/
          ctx2[0]
        );
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      ctx[3](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment15.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance15($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Embed", slots, []);
  let { content } = $$props;
  function findAndRunScripts() {
    if (!elem || !elem.getElementsByTagName)
      return;
    const scripts = elem.getElementsByTagName("script");
    for (let i = 0; i < scripts.length; i++) {
      const script = scripts[i];
      if (script.src && !scriptsInserted.includes(script.src)) {
        scriptsInserted.push(script.src);
        const newScript = document.createElement("script");
        newScript.async = true;
        newScript.src = script.src;
        document.head.appendChild(newScript);
      } else if (isJsScript(script) && !scriptsRun.includes(script.innerText)) {
        try {
          scriptsRun.push(script.innerText);
          new Function(script.innerText)();
        } catch (error) {
          console.warn("`Embed`: Error running script:", error);
        }
      }
    }
  }
  let elem;
  let scriptsInserted = [];
  let scriptsRun = [];
  let ranInitFn = false;
  function onUpdateFn_0() {
    if (elem && !ranInitFn) {
      $$invalidate(2, ranInitFn = true);
      findAndRunScripts();
    }
  }
  $$self.$$.on_mount.push(function() {
    if (content === void 0 && !("content" in $$props || $$self.$$.bound[$$self.$$.props["content"]])) {
      console_14.warn("<Embed> was created without expected prop 'content'");
    }
  });
  const writable_props = ["content"];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console_14.warn(`<Embed> was created with unknown prop '${key2}'`);
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      elem = $$value;
      $$invalidate(1, elem);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("content" in $$props2)
      $$invalidate(0, content = $$props2.content);
  };
  $$self.$capture_state = () => ({
    isJsScript,
    content,
    findAndRunScripts,
    elem,
    scriptsInserted,
    scriptsRun,
    ranInitFn,
    onUpdateFn_0
  });
  $$self.$inject_state = ($$props2) => {
    if ("content" in $$props2)
      $$invalidate(0, content = $$props2.content);
    if ("elem" in $$props2)
      $$invalidate(1, elem = $$props2.elem);
    if ("scriptsInserted" in $$props2)
      scriptsInserted = $$props2.scriptsInserted;
    if ("scriptsRun" in $$props2)
      scriptsRun = $$props2.scriptsRun;
    if ("ranInitFn" in $$props2)
      $$invalidate(2, ranInitFn = $$props2.ranInitFn);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*elem, ranInitFn*/
    6) {
      $:
        onUpdateFn_0(...[elem, ranInitFn]);
    }
  };
  return [content, elem, ranInitFn, div_binding];
}
var Embed = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance15, create_fragment15, safe_not_equal, { content: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Embed",
      options,
      id: create_fragment15.name
    });
  }
  get content() {
    throw new Error("<Embed>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set content(value) {
    throw new Error("<Embed>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var embed_default = Embed;

// node_modules/@builder.io/sdk-svelte/package/blocks/img/img.svelte
var { Object: Object_110 } = globals;
var file13 = "node_modules\\@builder.io\\sdk-svelte\\package\\blocks\\img\\img.svelte";
function create_fragment16(ctx) {
  let img;
  let img_key_value;
  let img_src_value;
  let mitosis_styling_action;
  let setAttrs_action;
  let mounted;
  let dispose;
  let img_levels = [
    {
      key: img_key_value = isEditing() && /*imgSrc*/
      ctx[2] || "default-key"
    },
    { alt: (
      /*altText*/
      ctx[3]
    ) },
    {
      src: img_src_value = /*imgSrc*/
      ctx[2] || /*image*/
      ctx[4]
    },
    /*filterAttrs*/
    ctx[8](
      /*attributes*/
      ctx[5],
      /*isNonEvent*/
      ctx[7]
    )
  ];
  let img_data = {};
  for (let i = 0; i < img_levels.length; i += 1) {
    img_data = assign(img_data, img_levels[i]);
  }
  const block = {
    c: function create() {
      img = element("img");
      this.h();
    },
    l: function claim(nodes) {
      img = claim_element(nodes, "IMG", { key: true, alt: true, src: true });
      this.h();
    },
    h: function hydrate() {
      set_attributes(img, img_data);
      add_location(img, file13, 48, 0, 1350);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, img, anchor);
      if (!mounted) {
        dispose = [
          action_destroyer(mitosis_styling_action = mitosis_styling7.call(null, img, {
            objectFit: (
              /*backgroundSize*/
              ctx[0] || "cover"
            ),
            objectPosition: (
              /*backgroundPosition*/
              ctx[1] || "center"
            )
          })),
          action_destroyer(setAttrs_action = /*setAttrs*/
          ctx[9].call(
            null,
            img,
            /*filterAttrs*/
            ctx[8](
              /*attributes*/
              ctx[5],
              /*isEvent*/
              ctx[6]
            )
          ))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      set_attributes(img, img_data = get_spread_update(img_levels, [
        dirty & /*imgSrc*/
        4 && img_key_value !== (img_key_value = isEditing() && /*imgSrc*/
        ctx2[2] || "default-key") && { key: img_key_value },
        dirty & /*altText*/
        8 && { alt: (
          /*altText*/
          ctx2[3]
        ) },
        dirty & /*imgSrc, image*/
        20 && !src_url_equal(img.src, img_src_value = /*imgSrc*/
        ctx2[2] || /*image*/
        ctx2[4]) && { src: img_src_value },
        dirty & /*attributes*/
        32 && /*filterAttrs*/
        ctx2[8](
          /*attributes*/
          ctx2[5],
          /*isNonEvent*/
          ctx2[7]
        )
      ]));
      if (mitosis_styling_action && is_function(mitosis_styling_action.update) && dirty & /*backgroundSize, backgroundPosition*/
      3)
        mitosis_styling_action.update.call(null, {
          objectFit: (
            /*backgroundSize*/
            ctx2[0] || "cover"
          ),
          objectPosition: (
            /*backgroundPosition*/
            ctx2[1] || "center"
          )
        });
      if (setAttrs_action && is_function(setAttrs_action.update) && dirty & /*attributes*/
      32)
        setAttrs_action.update.call(
          null,
          /*filterAttrs*/
          ctx2[8](
            /*attributes*/
            ctx2[5],
            /*isEvent*/
            ctx2[6]
          )
        );
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(img);
      }
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment16.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function mitosis_styling7(node, vars) {
  Object.entries(vars || {}).forEach(([p, v]) => {
    if (p.startsWith("--")) {
      node.style.setProperty(p, v);
    } else {
      node.style[p] = v;
    }
  });
}
function instance16($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Img", slots, []);
  const isEvent = (attr) => attr.startsWith("on:");
  const isNonEvent = (attr) => !attr.startsWith("on:");
  const filterAttrs = (attrs = {}, filter) => {
    const validAttr = {};
    Object.keys(attrs).forEach((attr) => {
      if (filter(attr)) {
        validAttr[attr] = attrs[attr];
      }
    });
    return validAttr;
  };
  const setAttrs = (node, attrs = {}) => {
    const attrKeys = Object.keys(attrs);
    const setup = (attr) => node.addEventListener(attr.substr(3), attrs[attr]);
    const teardown = (attr) => node.removeEventListener(attr.substr(3), attrs[attr]);
    attrKeys.map(setup);
    return {
      update(attrs2 = {}) {
        const attrKeys2 = Object.keys(attrs2);
        attrKeys2.map(teardown);
        attrKeys2.map(setup);
      },
      destroy() {
        attrKeys.map(teardown);
      }
    };
  };
  let { backgroundSize } = $$props;
  let { backgroundPosition } = $$props;
  let { imgSrc } = $$props;
  let { altText } = $$props;
  let { image } = $$props;
  let { attributes } = $$props;
  $$self.$$.on_mount.push(function() {
    if (backgroundSize === void 0 && !("backgroundSize" in $$props || $$self.$$.bound[$$self.$$.props["backgroundSize"]])) {
      console.warn("<Img> was created without expected prop 'backgroundSize'");
    }
    if (backgroundPosition === void 0 && !("backgroundPosition" in $$props || $$self.$$.bound[$$self.$$.props["backgroundPosition"]])) {
      console.warn("<Img> was created without expected prop 'backgroundPosition'");
    }
    if (imgSrc === void 0 && !("imgSrc" in $$props || $$self.$$.bound[$$self.$$.props["imgSrc"]])) {
      console.warn("<Img> was created without expected prop 'imgSrc'");
    }
    if (altText === void 0 && !("altText" in $$props || $$self.$$.bound[$$self.$$.props["altText"]])) {
      console.warn("<Img> was created without expected prop 'altText'");
    }
    if (image === void 0 && !("image" in $$props || $$self.$$.bound[$$self.$$.props["image"]])) {
      console.warn("<Img> was created without expected prop 'image'");
    }
    if (attributes === void 0 && !("attributes" in $$props || $$self.$$.bound[$$self.$$.props["attributes"]])) {
      console.warn("<Img> was created without expected prop 'attributes'");
    }
  });
  const writable_props = [
    "backgroundSize",
    "backgroundPosition",
    "imgSrc",
    "altText",
    "image",
    "attributes"
  ];
  Object_110.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<Img> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("backgroundSize" in $$props2)
      $$invalidate(0, backgroundSize = $$props2.backgroundSize);
    if ("backgroundPosition" in $$props2)
      $$invalidate(1, backgroundPosition = $$props2.backgroundPosition);
    if ("imgSrc" in $$props2)
      $$invalidate(2, imgSrc = $$props2.imgSrc);
    if ("altText" in $$props2)
      $$invalidate(3, altText = $$props2.altText);
    if ("image" in $$props2)
      $$invalidate(4, image = $$props2.image);
    if ("attributes" in $$props2)
      $$invalidate(5, attributes = $$props2.attributes);
  };
  $$self.$capture_state = () => ({
    isEditing,
    isEvent,
    isNonEvent,
    filterAttrs,
    setAttrs,
    backgroundSize,
    backgroundPosition,
    imgSrc,
    altText,
    image,
    attributes,
    mitosis_styling: mitosis_styling7
  });
  $$self.$inject_state = ($$props2) => {
    if ("backgroundSize" in $$props2)
      $$invalidate(0, backgroundSize = $$props2.backgroundSize);
    if ("backgroundPosition" in $$props2)
      $$invalidate(1, backgroundPosition = $$props2.backgroundPosition);
    if ("imgSrc" in $$props2)
      $$invalidate(2, imgSrc = $$props2.imgSrc);
    if ("altText" in $$props2)
      $$invalidate(3, altText = $$props2.altText);
    if ("image" in $$props2)
      $$invalidate(4, image = $$props2.image);
    if ("attributes" in $$props2)
      $$invalidate(5, attributes = $$props2.attributes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    backgroundSize,
    backgroundPosition,
    imgSrc,
    altText,
    image,
    attributes,
    isEvent,
    isNonEvent,
    filterAttrs,
    setAttrs
  ];
}
var Img = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance16, create_fragment16, safe_not_equal, {
      backgroundSize: 0,
      backgroundPosition: 1,
      imgSrc: 2,
      altText: 3,
      image: 4,
      attributes: 5
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Img",
      options,
      id: create_fragment16.name
    });
  }
  get backgroundSize() {
    throw new Error("<Img>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set backgroundSize(value) {
    throw new Error("<Img>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get backgroundPosition() {
    throw new Error("<Img>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set backgroundPosition(value) {
    throw new Error("<Img>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get imgSrc() {
    throw new Error("<Img>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set imgSrc(value) {
    throw new Error("<Img>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get altText() {
    throw new Error("<Img>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set altText(value) {
    throw new Error("<Img>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get image() {
    throw new Error("<Img>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set image(value) {
    throw new Error("<Img>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get attributes() {
    throw new Error("<Img>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set attributes(value) {
    throw new Error("<Img>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var img_default = Img;

// node_modules/@builder.io/sdk-svelte/package/blocks/img/component-info.js
var componentInfo10 = {
  // friendlyName?
  name: "Raw:Img",
  hideFromInsertMenu: true,
  image: "https://firebasestorage.googleapis.com/v0/b/builder-3b0a2.appspot.com/o/images%2Fbaseline-insert_photo-24px.svg?alt=media&token=4e5d0ef4-f5e8-4e57-b3a9-38d63a9b9dc4",
  inputs: [
    {
      name: "image",
      bubble: true,
      type: "file",
      allowedFileTypes: ["jpeg", "jpg", "png", "svg"],
      required: true
    }
  ],
  noWrap: true,
  static: true
};

// node_modules/@builder.io/sdk-svelte/package/blocks/custom-code/custom-code.svelte
var { console: console_15 } = globals;
var file14 = "node_modules\\@builder.io\\sdk-svelte\\package\\blocks\\custom-code\\custom-code.svelte";
function create_fragment17(ctx) {
  let div;
  let html_tag;
  let div_class_value;
  const block = {
    c: function create() {
      div = element("div");
      html_tag = new HtmlTagHydration(false);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      html_tag = claim_html_tag(div_nodes, false);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      html_tag.a = null;
      attr_dev(div, "class", div_class_value = "builder-custom-code" + /*replaceNodes*/
      (ctx[0] ? " replace-nodes" : ""));
      add_location(div, file14, 49, 0, 1623);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      html_tag.m(
        /*code*/
        ctx[1],
        div
      );
      ctx[3](div);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*code*/
      2)
        html_tag.p(
          /*code*/
          ctx2[1]
        );
      if (dirty & /*replaceNodes*/
      1 && div_class_value !== (div_class_value = "builder-custom-code" + /*replaceNodes*/
      (ctx2[0] ? " replace-nodes" : ""))) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      ctx[3](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment17.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance17($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Custom_code", slots, []);
  let { replaceNodes } = $$props;
  let { code } = $$props;
  function findAndRunScripts() {
    if (elem && elem.getElementsByTagName && typeof window !== "undefined") {
      const scripts = elem.getElementsByTagName("script");
      for (let i = 0; i < scripts.length; i++) {
        const script = scripts[i];
        if (script.src) {
          if (scriptsInserted.includes(script.src)) {
            continue;
          }
          scriptsInserted.push(script.src);
          const newScript = document.createElement("script");
          newScript.async = true;
          newScript.src = script.src;
          document.head.appendChild(newScript);
        } else if (!script.type || ["text/javascript", "application/javascript", "application/ecmascript"].includes(script.type)) {
          if (scriptsRun.includes(script.innerText)) {
            continue;
          }
          try {
            scriptsRun.push(script.innerText);
            new Function(script.innerText)();
          } catch (error) {
            console.warn("`CustomCode`: Error running script:", error);
          }
        }
      }
    }
  }
  let elem;
  let scriptsInserted = [];
  let scriptsRun = [];
  onMount(() => {
    findAndRunScripts();
  });
  $$self.$$.on_mount.push(function() {
    if (replaceNodes === void 0 && !("replaceNodes" in $$props || $$self.$$.bound[$$self.$$.props["replaceNodes"]])) {
      console_15.warn("<Custom_code> was created without expected prop 'replaceNodes'");
    }
    if (code === void 0 && !("code" in $$props || $$self.$$.bound[$$self.$$.props["code"]])) {
      console_15.warn("<Custom_code> was created without expected prop 'code'");
    }
  });
  const writable_props = ["replaceNodes", "code"];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console_15.warn(`<Custom_code> was created with unknown prop '${key2}'`);
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      elem = $$value;
      $$invalidate(2, elem);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("replaceNodes" in $$props2)
      $$invalidate(0, replaceNodes = $$props2.replaceNodes);
    if ("code" in $$props2)
      $$invalidate(1, code = $$props2.code);
  };
  $$self.$capture_state = () => ({
    onMount,
    replaceNodes,
    code,
    findAndRunScripts,
    elem,
    scriptsInserted,
    scriptsRun
  });
  $$self.$inject_state = ($$props2) => {
    if ("replaceNodes" in $$props2)
      $$invalidate(0, replaceNodes = $$props2.replaceNodes);
    if ("code" in $$props2)
      $$invalidate(1, code = $$props2.code);
    if ("elem" in $$props2)
      $$invalidate(2, elem = $$props2.elem);
    if ("scriptsInserted" in $$props2)
      scriptsInserted = $$props2.scriptsInserted;
    if ("scriptsRun" in $$props2)
      scriptsRun = $$props2.scriptsRun;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [replaceNodes, code, elem, div_binding];
}
var Custom_code = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance17, create_fragment17, safe_not_equal, { replaceNodes: 0, code: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Custom_code",
      options,
      id: create_fragment17.name
    });
  }
  get replaceNodes() {
    throw new Error("<Custom_code>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set replaceNodes(value) {
    throw new Error("<Custom_code>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get code() {
    throw new Error("<Custom_code>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set code(value) {
    throw new Error("<Custom_code>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var custom_code_default = Custom_code;

// node_modules/@builder.io/sdk-svelte/package/blocks/custom-code/component-info.js
var componentInfo11 = {
  name: "Custom Code",
  static: true,
  requiredPermissions: ["editCode"],
  inputs: [
    {
      name: "code",
      type: "html",
      required: true,
      defaultValue: "<p>Hello there, I am custom HTML code!</p>",
      code: true
    },
    {
      name: "replaceNodes",
      type: "boolean",
      helperText: "Preserve server rendered dom nodes",
      advanced: true
    },
    {
      name: "scriptsClientOnly",
      type: "boolean",
      defaultValue: false,
      helperText: "Only print and run scripts on the client. Important when scripts influence DOM that could be replaced when client loads",
      advanced: true
    }
  ]
};

// node_modules/@builder.io/sdk-svelte/package/constants/builder-registered-components.js
var getDefaultRegisteredComponents = () => [
  { component: button_default, ...componentInfo },
  { component: columns_default, ...componentInfo2 },
  { component: custom_code_default, ...componentInfo11 },
  { component: embed_default, ...componentInfo9 },
  { component: fragment_default, ...componentInfo3 },
  { component: image_default, ...componentInfo4 },
  { component: img_default, ...componentInfo10 },
  { component: section_default, ...componentInfo5 },
  { component: symbol_default, ...componentInfo6 },
  { component: text_default, ...componentInfo7 },
  { component: video_default, ...componentInfo8 }
];

// node_modules/@builder.io/sdk-svelte/package/functions/is-previewing.js
function isPreviewing() {
  if (!isBrowser()) {
    return false;
  }
  if (isEditing()) {
    return false;
  }
  return Boolean(location.search.indexOf("builder.preview=") !== -1);
}

// node_modules/@builder.io/sdk-svelte/package/functions/register-component.js
var components = [];
function registerComponent(component, info) {
  components.push({ component, ...info });
  console.warn("registerComponent is deprecated. Use the `customComponents` prop in RenderContent instead to provide your custom components to the builder SDK.");
  return component;
}
var createRegisterComponentMessage = ({ component: _, ...info }) => ({
  type: "builder.registerComponent",
  data: prepareComponentInfoToSend(info)
});
var serializeValue = (value) => typeof value === "function" ? serializeFn(value) : fastClone(value);
var prepareComponentInfoToSend = ({ inputs, ...info }) => ({
  ...fastClone(info),
  inputs: inputs == null ? void 0 : inputs.map((input) => Object.entries(input).reduce((acc, [key2, value]) => ({
    ...acc,
    [key2]: serializeValue(value)
  }), {}))
});

// node_modules/@builder.io/sdk-svelte/package/helpers/uuid.js
function uuidv4() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
    const r = Math.random() * 16 | 0, v = c == "x" ? r : r & 3 | 8;
    return v.toString(16);
  });
}
function uuid() {
  return uuidv4().replace(/-/g, "");
}

// node_modules/@builder.io/sdk-svelte/package/helpers/sessionId.js
var SESSION_LOCAL_STORAGE_KEY = "builderSessionId";
var getSessionId = async ({ canTrack }) => {
  if (!canTrack) {
    return void 0;
  }
  const sessionId = await getCookie({
    name: SESSION_LOCAL_STORAGE_KEY,
    canTrack
  });
  if (checkIsDefined(sessionId)) {
    return sessionId;
  } else {
    const newSessionId = createSessionId();
    setSessionId({ id: newSessionId, canTrack });
    return newSessionId;
  }
};
var createSessionId = () => uuid();
var setSessionId = ({ id, canTrack }) => setCookie({ name: SESSION_LOCAL_STORAGE_KEY, value: id, canTrack });

// node_modules/@builder.io/sdk-svelte/package/helpers/localStorage.js
var getLocalStorage = () => isBrowser() && typeof localStorage !== "undefined" ? localStorage : void 0;
var getLocalStorageItem = ({ key: key2, canTrack }) => {
  var _a;
  try {
    if (canTrack) {
      return (_a = getLocalStorage()) == null ? void 0 : _a.getItem(key2);
    }
    return void 0;
  } catch (err) {
    console.debug("[LocalStorage] GET error: ", err);
    return void 0;
  }
};
var setLocalStorageItem = ({ key: key2, canTrack, value }) => {
  var _a;
  try {
    if (canTrack) {
      (_a = getLocalStorage()) == null ? void 0 : _a.setItem(key2, value);
    }
  } catch (err) {
    console.debug("[LocalStorage] SET error: ", err);
  }
};

// node_modules/@builder.io/sdk-svelte/package/helpers/visitorId.js
var VISITOR_LOCAL_STORAGE_KEY = "builderVisitorId";
var getVisitorId = ({ canTrack }) => {
  if (!canTrack) {
    return void 0;
  }
  const visitorId = getLocalStorageItem({
    key: VISITOR_LOCAL_STORAGE_KEY,
    canTrack
  });
  if (checkIsDefined(visitorId)) {
    return visitorId;
  } else {
    const newVisitorId = createVisitorId();
    setVisitorId({ id: newVisitorId, canTrack });
    return newVisitorId;
  }
};
var createVisitorId = () => uuid();
var setVisitorId = ({ id, canTrack }) => setLocalStorageItem({
  key: VISITOR_LOCAL_STORAGE_KEY,
  value: id,
  canTrack
});

// node_modules/@builder.io/sdk-svelte/package/functions/track/helpers.js
var getLocation = () => {
  if (TARGET === "reactNative") {
    return null;
  } else if (isBrowser()) {
    const parsedLocation = new URL(location.href);
    if (parsedLocation.pathname === "") {
      parsedLocation.pathname = "/";
    }
    return parsedLocation;
  } else {
    console.warn("Cannot get location for tracking in non-browser environment");
    return null;
  }
};
var getUserAgent = () => typeof navigator === "object" && navigator.userAgent || "";
var getUserAttributes = () => {
  const userAgent = getUserAgent();
  const isMobile = {
    Android() {
      return userAgent.match(/Android/i);
    },
    BlackBerry() {
      return userAgent.match(/BlackBerry/i);
    },
    iOS() {
      return userAgent.match(/iPhone|iPod/i);
    },
    Opera() {
      return userAgent.match(/Opera Mini/i);
    },
    Windows() {
      return userAgent.match(/IEMobile/i) || userAgent.match(/WPDesktop/i);
    },
    any() {
      return isMobile.Android() || isMobile.BlackBerry() || isMobile.iOS() || isMobile.Opera() || isMobile.Windows() || TARGET === "reactNative";
    }
  };
  const isTablet = userAgent.match(/Tablet|iPad/i);
  const url = getLocation();
  return {
    urlPath: url == null ? void 0 : url.pathname,
    host: (url == null ? void 0 : url.host) || (url == null ? void 0 : url.hostname),
    device: isTablet ? "tablet" : isMobile.any() ? "mobile" : "desktop"
  };
};

// node_modules/@builder.io/sdk-svelte/package/functions/track/index.js
var getTrackingEventData = async ({ canTrack }) => {
  if (!canTrack) {
    return { visitorId: void 0, sessionId: void 0 };
  }
  const sessionId = await getSessionId({ canTrack });
  const visitorId = getVisitorId({ canTrack });
  return {
    sessionId,
    visitorId
  };
};
var createEvent = async ({ type: eventType, canTrack, apiKey, metadata, ...properties }) => ({
  type: eventType,
  data: {
    ...properties,
    metadata: {
      url: location.href,
      ...metadata
    },
    ...await getTrackingEventData({ canTrack }),
    userAttributes: getUserAttributes(),
    ownerId: apiKey
  }
});
async function _track(eventProps) {
  if (!eventProps.apiKey) {
    console.error("[Builder.io]: Missing API key for track call. Please provide your API key.");
    return;
  }
  if (!eventProps.canTrack) {
    return;
  }
  if (isEditing()) {
    return;
  }
  if (!(isBrowser() || TARGET === "reactNative")) {
    return;
  }
  return fetch(`https://builder.io/api/v1/track`, {
    method: "POST",
    body: JSON.stringify({
      events: [await createEvent(eventProps)]
    }),
    headers: {
      "content-type": "application/json"
    },
    mode: "cors"
  }).catch((err) => {
    console.error("Failed to track: ", err);
  });
}
var track = (args) => _track({ ...args, canTrack: true });

// node_modules/@builder.io/sdk-svelte/package/components/render-content/components/render-styles.helpers.js
var getCssFromFont = (font) => {
  var _a;
  const family = font.family + (font.kind && !font.kind.includes("#") ? ", " + font.kind : "");
  const name = family.split(",")[0];
  const url = font.fileUrl ?? ((_a = font == null ? void 0 : font.files) == null ? void 0 : _a.regular);
  let str = "";
  if (url && family && name) {
    str += `
@font-face {
font-family: "${family}";
src: local("${name}"), url('${url}') format('woff2');
font-display: fallback;
font-weight: 400;
}
      `.trim();
  }
  if (font.files) {
    for (const weight in font.files) {
      const isNumber = String(Number(weight)) === weight;
      if (!isNumber) {
        continue;
      }
      const weightUrl = font.files[weight];
      if (weightUrl && weightUrl !== url) {
        str += `
@font-face {
font-family: "${family}";
src: url('${weightUrl}') format('woff2');
font-display: fallback;
font-weight: ${weight};
}
        `.trim();
      }
    }
  }
  return str;
};
var getFontCss = ({ customFonts }) => {
  var _a;
  return ((_a = customFonts == null ? void 0 : customFonts.map((font) => getCssFromFont(font))) == null ? void 0 : _a.join(" ")) || "";
};
var getCss = ({ cssCode, contentId }) => {
  if (!cssCode) {
    return "";
  }
  if (!contentId) {
    return cssCode;
  }
  return (cssCode == null ? void 0 : cssCode.replace(/&/g, `div[builder-content-id="${contentId}"]`)) || "";
};

// node_modules/@builder.io/sdk-svelte/package/components/render-content/components/render-styles.svelte
function create_fragment18(ctx) {
  let renderinlinedstyles;
  let current;
  renderinlinedstyles = new render_inlined_styles_default({
    props: { styles: (
      /*injectedStyles*/
      ctx[0]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(renderinlinedstyles.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(renderinlinedstyles.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(renderinlinedstyles, target, anchor);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(renderinlinedstyles.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(renderinlinedstyles.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(renderinlinedstyles, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment18.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance18($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Render_styles", slots, []);
  let { cssCode } = $$props;
  let { contentId } = $$props;
  let { customFonts } = $$props;
  let injectedStyles = `
${getCss({ cssCode, contentId })}
${getFontCss({ customFonts })}

.builder-text > p:first-of-type, .builder-text > .builder-paragraph:first-of-type {
margin: 0;
}
.builder-text > p, .builder-text > .builder-paragraph {
color: inherit;
line-height: inherit;
letter-spacing: inherit;
font-weight: inherit;
font-size: inherit;
text-align: inherit;
font-family: inherit;
}
`;
  $$self.$$.on_mount.push(function() {
    if (cssCode === void 0 && !("cssCode" in $$props || $$self.$$.bound[$$self.$$.props["cssCode"]])) {
      console.warn("<Render_styles> was created without expected prop 'cssCode'");
    }
    if (contentId === void 0 && !("contentId" in $$props || $$self.$$.bound[$$self.$$.props["contentId"]])) {
      console.warn("<Render_styles> was created without expected prop 'contentId'");
    }
    if (customFonts === void 0 && !("customFonts" in $$props || $$self.$$.bound[$$self.$$.props["customFonts"]])) {
      console.warn("<Render_styles> was created without expected prop 'customFonts'");
    }
  });
  const writable_props = ["cssCode", "contentId", "customFonts"];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<Render_styles> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("cssCode" in $$props2)
      $$invalidate(1, cssCode = $$props2.cssCode);
    if ("contentId" in $$props2)
      $$invalidate(2, contentId = $$props2.contentId);
    if ("customFonts" in $$props2)
      $$invalidate(3, customFonts = $$props2.customFonts);
  };
  $$self.$capture_state = () => ({
    RenderInlinedStyles: render_inlined_styles_default,
    getCss,
    getFontCss,
    cssCode,
    contentId,
    customFonts,
    injectedStyles
  });
  $$self.$inject_state = ($$props2) => {
    if ("cssCode" in $$props2)
      $$invalidate(1, cssCode = $$props2.cssCode);
    if ("contentId" in $$props2)
      $$invalidate(2, contentId = $$props2.contentId);
    if ("customFonts" in $$props2)
      $$invalidate(3, customFonts = $$props2.customFonts);
    if ("injectedStyles" in $$props2)
      $$invalidate(0, injectedStyles = $$props2.injectedStyles);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [injectedStyles, cssCode, contentId, customFonts];
}
var Render_styles = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance18, create_fragment18, safe_not_equal, { cssCode: 1, contentId: 2, customFonts: 3 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Render_styles",
      options,
      id: create_fragment18.name
    });
  }
  get cssCode() {
    throw new Error("<Render_styles>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set cssCode(value) {
    throw new Error("<Render_styles>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get contentId() {
    throw new Error("<Render_styles>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set contentId(value) {
    throw new Error("<Render_styles>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get customFonts() {
    throw new Error("<Render_styles>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set customFonts(value) {
    throw new Error("<Render_styles>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var render_styles_default = Render_styles;

// node_modules/@builder.io/sdk-svelte/package/functions/register.js
var registry = {};
function register(type, info) {
  let typeList = registry[type];
  if (!typeList) {
    typeList = registry[type] = [];
  }
  typeList.push(info);
  if (isBrowser()) {
    const message = {
      type: "builder.register",
      data: {
        type,
        info
      }
    };
    try {
      parent.postMessage(message, "*");
      if (parent !== window) {
        window.postMessage(message, "*");
      }
    } catch (err) {
      console.debug("Could not postmessage", err);
    }
  }
}

// node_modules/@builder.io/sdk-svelte/package/scripts/init-editing.js
var registerInsertMenu = () => {
  register("insertMenu", {
    name: "_default",
    default: true,
    items: [
      { name: "Box" },
      { name: "Text" },
      { name: "Image" },
      { name: "Columns" },
      ...TARGET === "reactNative" ? [] : [
        { name: "Core:Section" },
        { name: "Core:Button" },
        { name: "Embed" },
        { name: "Custom Code" }
      ]
    ]
  });
};
var isSetupForEditing = false;
var setupBrowserForEditing = (options = {}) => {
  var _a, _b;
  if (isSetupForEditing) {
    return;
  }
  isSetupForEditing = true;
  if (isBrowser()) {
    (_a = window.parent) == null ? void 0 : _a.postMessage({
      type: "builder.sdkInfo",
      data: {
        target: TARGET,
        // TODO: compile these in
        // type: process.env.SDK_TYPE,
        // version: process.env.SDK_VERSION,
        supportsPatchUpdates: false,
        // Supports builder-model="..." attribute which is needed to
        // scope our '+ add block' button styling
        supportsAddBlockScoping: true,
        supportsCustomBreakpoints: true
      }
    }, "*");
    (_b = window.parent) == null ? void 0 : _b.postMessage({
      type: "builder.updateContent",
      data: {
        options
      }
    }, "*");
    window.addEventListener("message", ({ data }) => {
      var _a2, _b2;
      if (!(data == null ? void 0 : data.type)) {
        return;
      }
      switch (data.type) {
        case "builder.evaluate": {
          const text2 = data.data.text;
          const args = data.data.arguments || [];
          const id = data.data.id;
          const fn = new Function(text2);
          let result;
          let error = null;
          try {
            result = fn.apply(null, args);
          } catch (err) {
            error = err;
          }
          if (error) {
            (_a2 = window.parent) == null ? void 0 : _a2.postMessage({
              type: "builder.evaluateError",
              data: { id, error: error.message }
            }, "*");
          } else {
            if (result && typeof result.then === "function") {
              result.then((finalResult) => {
                var _a3;
                (_a3 = window.parent) == null ? void 0 : _a3.postMessage({
                  type: "builder.evaluateResult",
                  data: { id, result: finalResult }
                }, "*");
              }).catch(console.error);
            } else {
              (_b2 = window.parent) == null ? void 0 : _b2.postMessage({
                type: "builder.evaluateResult",
                data: { result, id }
              }, "*");
            }
          }
          break;
        }
      }
    });
  }
};

// node_modules/@builder.io/sdk-svelte/package/functions/track/interaction.js
function round(num) {
  return Math.round(num * 1e3) / 1e3;
}
var findParentElement = (target, callback, checkElement = true) => {
  if (!(target instanceof HTMLElement)) {
    return null;
  }
  let parent2 = checkElement ? target : target.parentElement;
  do {
    if (!parent2) {
      return null;
    }
    const matches = callback(parent2);
    if (matches) {
      return parent2;
    }
  } while (parent2 = parent2.parentElement);
  return null;
};
var findBuilderParent = (target) => findParentElement(target, (el) => {
  const id = el.getAttribute("builder-id") || el.id;
  return Boolean((id == null ? void 0 : id.indexOf("builder-")) === 0);
});
var computeOffset = ({ event, target }) => {
  const targetRect = target.getBoundingClientRect();
  const xOffset = event.clientX - targetRect.left;
  const yOffset = event.clientY - targetRect.top;
  const xRatio = round(xOffset / targetRect.width);
  const yRatio = round(yOffset / targetRect.height);
  return {
    x: xRatio,
    y: yRatio
  };
};
var getInteractionPropertiesForEvent = (event) => {
  const target = event.target;
  const targetBuilderElement = target && findBuilderParent(target);
  const builderId = (targetBuilderElement == null ? void 0 : targetBuilderElement.getAttribute("builder-id")) || (targetBuilderElement == null ? void 0 : targetBuilderElement.id);
  return {
    targetBuilderElement: builderId || void 0,
    metadata: {
      targetOffset: target ? computeOffset({ event, target }) : void 0,
      builderTargetOffset: targetBuilderElement ? computeOffset({ event, target: targetBuilderElement }) : void 0,
      builderElementIndex: targetBuilderElement && builderId ? [].slice.call(document.getElementsByClassName(builderId)).indexOf(targetBuilderElement) : void 0
    }
  };
};

// node_modules/@builder.io/sdk-svelte/package/components/render-content/render-content.helpers.js
var getContextStateInitialValue = ({ content, data, locale }) => {
  var _a, _b, _c;
  const defaultValues = {};
  (_b = (_a = content == null ? void 0 : content.data) == null ? void 0 : _a.inputs) == null ? void 0 : _b.forEach((input) => {
    var _a2;
    if (input.name && input.defaultValue !== void 0 && ((_a2 = content == null ? void 0 : content.data) == null ? void 0 : _a2.state) && content.data.state[input.name] === void 0) {
      defaultValues[input.name] = input.defaultValue;
    }
  });
  const stateToUse = {
    ...(_c = content == null ? void 0 : content.data) == null ? void 0 : _c.state,
    ...data,
    ...locale ? { locale } : {}
  };
  return { ...defaultValues, ...stateToUse };
};
var getContentInitialValue = ({ content, data }) => {
  return !content ? void 0 : {
    ...content,
    data: {
      ...content == null ? void 0 : content.data,
      ...data
    },
    meta: content == null ? void 0 : content.meta
  };
};

// node_modules/@builder.io/sdk-svelte/package/components/render-content/render-content.svelte
var { Object: Object_111, console: console_16 } = globals;
var file15 = "node_modules\\@builder.io\\sdk-svelte\\package\\components\\render-content\\render-content.svelte";
function create_if_block9(ctx) {
  var _a, _b;
  let div;
  let t;
  let renderblocks;
  let div_builder_content_id_value;
  let current;
  let mounted;
  let dispose;
  let if_block = TARGET !== "reactNative" && create_if_block_14(ctx);
  renderblocks = new render_blocks_default({
    props: {
      blocks: (
        /*useContent*/
        (_b = (_a = ctx[1]) == null ? void 0 : _a.data) == null ? void 0 : _b.blocks
      ),
      key: (
        /*forceReRenderCount*/
        ctx[3]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element("div");
      if (if_block)
        if_block.c();
      t = space();
      create_component(renderblocks.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {
        "builder-content-id": true,
        "builder-model": true
      });
      var div_nodes = children(div);
      if (if_block)
        if_block.l(div_nodes);
      t = claim_space(div_nodes);
      claim_component(renderblocks.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      var _a2;
      attr_dev(div, "builder-content-id", div_builder_content_id_value = /*useContent*/
      (_a2 = ctx[1]) == null ? void 0 : _a2.id);
      attr_dev(
        div,
        "builder-model",
        /*model*/
        ctx[0]
      );
      add_location(div, file15, 319, 2, 10760);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      append_hydration_dev(div, t);
      mount_component(renderblocks, div, null);
      ctx[15](div);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          div,
          "click",
          /*click_handler*/
          ctx[16],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      var _a2, _b2, _c;
      if (TARGET !== "reactNative")
        if_block.p(ctx2, dirty);
      const renderblocks_changes = {};
      if (dirty[0] & /*useContent*/
      2)
        renderblocks_changes.blocks = /*useContent*/
        (_b2 = (_a2 = ctx2[1]) == null ? void 0 : _a2.data) == null ? void 0 : _b2.blocks;
      if (dirty[0] & /*forceReRenderCount*/
      8)
        renderblocks_changes.key = /*forceReRenderCount*/
        ctx2[3];
      renderblocks.$set(renderblocks_changes);
      if (!current || dirty[0] & /*useContent*/
      2 && div_builder_content_id_value !== (div_builder_content_id_value = /*useContent*/
      (_c = ctx2[1]) == null ? void 0 : _c.id)) {
        attr_dev(div, "builder-content-id", div_builder_content_id_value);
      }
      if (!current || dirty[0] & /*model*/
      1) {
        attr_dev(
          div,
          "builder-model",
          /*model*/
          ctx2[0]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(renderblocks.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(renderblocks.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (if_block)
        if_block.d();
      destroy_component(renderblocks);
      ctx[15](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block9.name,
    type: "if",
    source: "(319:0) {#if useContent}",
    ctx
  });
  return block;
}
function create_if_block_14(ctx) {
  var _a, _b, _c, _d, _e;
  let rendercontentstyles;
  let current;
  rendercontentstyles = new render_styles_default({
    props: {
      contentId: (
        /*useContent*/
        (_a = ctx[1]) == null ? void 0 : _a.id
      ),
      cssCode: (
        /*useContent*/
        (_c = (_b = ctx[1]) == null ? void 0 : _b.data) == null ? void 0 : _c.cssCode
      ),
      customFonts: (
        /*useContent*/
        (_e = (_d = ctx[1]) == null ? void 0 : _d.data) == null ? void 0 : _e.customFonts
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(rendercontentstyles.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(rendercontentstyles.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(rendercontentstyles, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      var _a2, _b2, _c2, _d2, _e2;
      const rendercontentstyles_changes = {};
      if (dirty[0] & /*useContent*/
      2)
        rendercontentstyles_changes.contentId = /*useContent*/
        (_a2 = ctx2[1]) == null ? void 0 : _a2.id;
      if (dirty[0] & /*useContent*/
      2)
        rendercontentstyles_changes.cssCode = /*useContent*/
        (_c2 = (_b2 = ctx2[1]) == null ? void 0 : _b2.data) == null ? void 0 : _c2.cssCode;
      if (dirty[0] & /*useContent*/
      2)
        rendercontentstyles_changes.customFonts = /*useContent*/
        (_e2 = (_d2 = ctx2[1]) == null ? void 0 : _d2.data) == null ? void 0 : _e2.customFonts;
      rendercontentstyles.$set(rendercontentstyles_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(rendercontentstyles.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(rendercontentstyles.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(rendercontentstyles, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_14.name,
    type: "if",
    source: '(328:4) {#if TARGET !== \\"reactNative\\"}',
    ctx
  });
  return block;
}
function create_fragment19(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*useContent*/
    ctx[1] && create_if_block9(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*useContent*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*useContent*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block9(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment19.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance19($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Render_content", slots, []);
  let { content } = $$props;
  let { data } = $$props;
  let { canTrack } = $$props;
  let { locale } = $$props;
  let { customComponents } = $$props;
  let { model } = $$props;
  let { context } = $$props;
  let { apiKey } = $$props;
  let { includeRefs } = $$props;
  let { apiVersion } = $$props;
  function mergeNewContent(newContent) {
    var _a, _b;
    $$invalidate(1, useContent = {
      ...useContent,
      ...newContent,
      data: { ...useContent == null ? void 0 : useContent.data, ...newContent == null ? void 0 : newContent.data },
      meta: {
        ...useContent == null ? void 0 : useContent.meta,
        ...newContent == null ? void 0 : newContent.meta,
        breakpoints: ((_a = newContent == null ? void 0 : newContent.meta) == null ? void 0 : _a.breakpoints) || ((_b = useContent == null ? void 0 : useContent.meta) == null ? void 0 : _b.breakpoints)
      }
    });
  }
  function setBreakpoints(breakpoints) {
    $$invalidate(1, useContent = {
      ...useContent,
      meta: { ...useContent == null ? void 0 : useContent.meta, breakpoints }
    });
  }
  function setContextState(newState) {
    $$invalidate(14, contentState = newState);
  }
  function processMessage(event) {
    const { data: data2 } = event;
    if (data2) {
      switch (data2.type) {
        case "builder.configureSdk": {
          const messageContent = data2.data;
          const { breakpoints, contentId } = messageContent;
          if (!contentId || contentId !== (useContent == null ? void 0 : useContent.id)) {
            return;
          }
          if (breakpoints) {
            setBreakpoints(breakpoints);
          }
          $$invalidate(3, forceReRenderCount = forceReRenderCount + 1);
          break;
        }
        case "builder.contentUpdate": {
          const messageContent = data2.data;
          const key2 = messageContent.key || messageContent.alias || messageContent.entry || messageContent.modelName;
          const contentData = messageContent.data;
          if (key2 === model) {
            mergeNewContent(contentData);
            $$invalidate(3, forceReRenderCount = forceReRenderCount + 1);
          }
          break;
        }
        case "builder.patchUpdates": {
          break;
        }
      }
    }
  }
  function evaluateJsCode() {
    var _a;
    const jsCode = (_a = useContent == null ? void 0 : useContent.data) == null ? void 0 : _a.jsCode;
    if (jsCode) {
      evaluate({
        code: jsCode,
        context: context || {},
        state: contentState
      });
    }
  }
  function onClick(event) {
    if (useContent) {
      const variationId = useContent == null ? void 0 : useContent.testVariationId;
      const contentId = useContent == null ? void 0 : useContent.id;
      _track({
        type: "click",
        canTrack: canTrackToUse,
        contentId,
        apiKey,
        variationId: variationId !== contentId ? variationId : void 0,
        ...getInteractionPropertiesForEvent(event),
        unique: !clicked
      });
    }
    if (!clicked) {
      clicked = true;
    }
  }
  function evalExpression(expression) {
    return expression.replace(/{{([^}]+)}}/g, (_match, group) => evaluate({
      code: group,
      context: context || {},
      state: contentState
    }));
  }
  function handleRequest({ url, key: key2 }) {
    fetch2(url).then((response) => response.json()).then((json) => {
      const newState = { ...contentState, [key2]: json };
      setContextState(newState);
    }).catch((err) => {
      console.error("error fetching dynamic data", url, err);
    });
  }
  function runHttpRequests() {
    var _a;
    const requests = ((_a = useContent == null ? void 0 : useContent.data) == null ? void 0 : _a.httpRequests) ?? {};
    Object.entries(requests).forEach(([key2, url]) => {
      if (url && (!httpReqsData[key2] || isEditing())) {
        const evaluatedUrl = evalExpression(url);
        handleRequest({ url: evaluatedUrl, key: key2 });
      }
    });
  }
  function emitStateUpdate() {
    if (isEditing()) {
      window.dispatchEvent(new CustomEvent(
        "builder:component:stateChange",
        {
          detail: {
            state: contentState,
            ref: { name: model }
          }
        }
      ));
    }
  }
  let elementRef;
  let forceReRenderCount = 0;
  let overrideContent = null;
  let useContent = getContentInitialValue({ content, data });
  let update = 0;
  let canTrackToUse = checkIsDefined(canTrack) ? canTrack : true;
  let contentState = getContextStateInitialValue({ content, data, locale });
  let allRegisteredComponents = [
    ...getDefaultRegisteredComponents(),
    // While this `components` object is deprecated, we must maintain support for it.
    // Since users are able to override our default components, we need to make sure that we do not break such
    // existing usage.
    // This is why we spread `components` after the default Builder.io components, but before the `props.customComponents`,
    // which is the new standard way of providing custom components, and must therefore take precedence.
    ...components,
    ...customComponents || []
  ].reduce((acc, curr) => ({ ...acc, [curr.name]: curr }), {});
  let httpReqsData = {};
  let clicked = false;
  onMount(() => {
    if (!apiKey) {
      console.error("[Builder.io]: No API key provided to `RenderContent` component. This can cause issues. Please provide an API key using the `apiKey` prop.");
    }
    if (isBrowser()) {
      if (isEditing()) {
        $$invalidate(3, forceReRenderCount = forceReRenderCount + 1);
        registerInsertMenu();
        setupBrowserForEditing({
          ...locale ? { locale } : {},
          ...includeRefs ? { includeRefs } : {}
        });
        Object.values(allRegisteredComponents).forEach((registeredComponent) => {
          var _a;
          const message = createRegisterComponentMessage(registeredComponent);
          (_a = window.parent) == null ? void 0 : _a.postMessage(message, "*");
        });
        window.addEventListener("message", processMessage);
        window.addEventListener("builder:component:stateChangeListenerActivated", emitStateUpdate);
      }
      if (useContent) {
        const variationId = useContent == null ? void 0 : useContent.testVariationId;
        const contentId = useContent == null ? void 0 : useContent.id;
        _track({
          type: "impression",
          canTrack: canTrackToUse,
          contentId,
          apiKey,
          variationId: variationId !== contentId ? variationId : void 0
        });
      }
      if (isPreviewing()) {
        const searchParams = new URL(location.href).searchParams;
        const searchParamPreview = searchParams.get("builder.preview");
        const previewApiKey = searchParams.get("apiKey") || searchParams.get("builder.space");
        if (searchParamPreview === model && previewApiKey === apiKey) {
          getContent({ model, apiKey, apiVersion }).then((content2) => {
            if (content2) {
              mergeNewContent(content2);
            }
          });
        }
      }
      evaluateJsCode();
      runHttpRequests();
      emitStateUpdate();
    }
  });
  function onUpdateFn_0() {
    if (content) {
      mergeNewContent(content);
    }
  }
  function onUpdateFn_1() {
    evaluateJsCode();
  }
  function onUpdateFn_2() {
    runHttpRequests();
  }
  function onUpdateFn_3() {
    emitStateUpdate();
  }
  setContext(builder_context_default.key, {
    get content() {
      return useContent;
    },
    get state() {
      return contentState;
    },
    get setState() {
      return setContextState;
    },
    get context() {
      return context || {};
    },
    get apiKey() {
      return apiKey;
    },
    get apiVersion() {
      return apiVersion;
    },
    get registeredComponents() {
      return allRegisteredComponents;
    }
  });
  onDestroy(() => {
    if (isBrowser()) {
      window.removeEventListener("message", processMessage);
      window.removeEventListener("builder:component:stateChangeListenerActivated", emitStateUpdate);
    }
  });
  $$self.$$.on_mount.push(function() {
    if (content === void 0 && !("content" in $$props || $$self.$$.bound[$$self.$$.props["content"]])) {
      console_16.warn("<Render_content> was created without expected prop 'content'");
    }
    if (data === void 0 && !("data" in $$props || $$self.$$.bound[$$self.$$.props["data"]])) {
      console_16.warn("<Render_content> was created without expected prop 'data'");
    }
    if (canTrack === void 0 && !("canTrack" in $$props || $$self.$$.bound[$$self.$$.props["canTrack"]])) {
      console_16.warn("<Render_content> was created without expected prop 'canTrack'");
    }
    if (locale === void 0 && !("locale" in $$props || $$self.$$.bound[$$self.$$.props["locale"]])) {
      console_16.warn("<Render_content> was created without expected prop 'locale'");
    }
    if (customComponents === void 0 && !("customComponents" in $$props || $$self.$$.bound[$$self.$$.props["customComponents"]])) {
      console_16.warn("<Render_content> was created without expected prop 'customComponents'");
    }
    if (model === void 0 && !("model" in $$props || $$self.$$.bound[$$self.$$.props["model"]])) {
      console_16.warn("<Render_content> was created without expected prop 'model'");
    }
    if (context === void 0 && !("context" in $$props || $$self.$$.bound[$$self.$$.props["context"]])) {
      console_16.warn("<Render_content> was created without expected prop 'context'");
    }
    if (apiKey === void 0 && !("apiKey" in $$props || $$self.$$.bound[$$self.$$.props["apiKey"]])) {
      console_16.warn("<Render_content> was created without expected prop 'apiKey'");
    }
    if (includeRefs === void 0 && !("includeRefs" in $$props || $$self.$$.bound[$$self.$$.props["includeRefs"]])) {
      console_16.warn("<Render_content> was created without expected prop 'includeRefs'");
    }
    if (apiVersion === void 0 && !("apiVersion" in $$props || $$self.$$.bound[$$self.$$.props["apiVersion"]])) {
      console_16.warn("<Render_content> was created without expected prop 'apiVersion'");
    }
  });
  const writable_props = [
    "content",
    "data",
    "canTrack",
    "locale",
    "customComponents",
    "model",
    "context",
    "apiKey",
    "includeRefs",
    "apiVersion"
  ];
  Object_111.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console_16.warn(`<Render_content> was created with unknown prop '${key2}'`);
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      elementRef = $$value;
      $$invalidate(2, elementRef);
    });
  }
  const click_handler = (event) => {
    onClick(event);
  };
  $$self.$$set = ($$props2) => {
    if ("content" in $$props2)
      $$invalidate(5, content = $$props2.content);
    if ("data" in $$props2)
      $$invalidate(6, data = $$props2.data);
    if ("canTrack" in $$props2)
      $$invalidate(7, canTrack = $$props2.canTrack);
    if ("locale" in $$props2)
      $$invalidate(8, locale = $$props2.locale);
    if ("customComponents" in $$props2)
      $$invalidate(9, customComponents = $$props2.customComponents);
    if ("model" in $$props2)
      $$invalidate(0, model = $$props2.model);
    if ("context" in $$props2)
      $$invalidate(10, context = $$props2.context);
    if ("apiKey" in $$props2)
      $$invalidate(11, apiKey = $$props2.apiKey);
    if ("includeRefs" in $$props2)
      $$invalidate(12, includeRefs = $$props2.includeRefs);
    if ("apiVersion" in $$props2)
      $$invalidate(13, apiVersion = $$props2.apiVersion);
  };
  $$self.$capture_state = () => ({
    onDestroy,
    onMount,
    setContext,
    getDefaultRegisteredComponents,
    evaluate,
    getContent,
    fetch: fetch2,
    isBrowser,
    isEditing,
    isPreviewing,
    components,
    createRegisterComponentMessage,
    _track,
    RenderBlocks: render_blocks_default,
    RenderContentStyles: render_styles_default,
    builderContext: builder_context_default,
    registerInsertMenu,
    setupBrowserForEditing,
    checkIsDefined,
    getInteractionPropertiesForEvent,
    getContentInitialValue,
    getContextStateInitialValue,
    TARGET,
    content,
    data,
    canTrack,
    locale,
    customComponents,
    model,
    context,
    apiKey,
    includeRefs,
    apiVersion,
    mergeNewContent,
    setBreakpoints,
    setContextState,
    processMessage,
    evaluateJsCode,
    onClick,
    evalExpression,
    handleRequest,
    runHttpRequests,
    emitStateUpdate,
    elementRef,
    forceReRenderCount,
    overrideContent,
    useContent,
    update,
    canTrackToUse,
    contentState,
    allRegisteredComponents,
    httpReqsData,
    clicked,
    onUpdateFn_0,
    onUpdateFn_1,
    onUpdateFn_2,
    onUpdateFn_3
  });
  $$self.$inject_state = ($$props2) => {
    if ("content" in $$props2)
      $$invalidate(5, content = $$props2.content);
    if ("data" in $$props2)
      $$invalidate(6, data = $$props2.data);
    if ("canTrack" in $$props2)
      $$invalidate(7, canTrack = $$props2.canTrack);
    if ("locale" in $$props2)
      $$invalidate(8, locale = $$props2.locale);
    if ("customComponents" in $$props2)
      $$invalidate(9, customComponents = $$props2.customComponents);
    if ("model" in $$props2)
      $$invalidate(0, model = $$props2.model);
    if ("context" in $$props2)
      $$invalidate(10, context = $$props2.context);
    if ("apiKey" in $$props2)
      $$invalidate(11, apiKey = $$props2.apiKey);
    if ("includeRefs" in $$props2)
      $$invalidate(12, includeRefs = $$props2.includeRefs);
    if ("apiVersion" in $$props2)
      $$invalidate(13, apiVersion = $$props2.apiVersion);
    if ("elementRef" in $$props2)
      $$invalidate(2, elementRef = $$props2.elementRef);
    if ("forceReRenderCount" in $$props2)
      $$invalidate(3, forceReRenderCount = $$props2.forceReRenderCount);
    if ("overrideContent" in $$props2)
      overrideContent = $$props2.overrideContent;
    if ("useContent" in $$props2)
      $$invalidate(1, useContent = $$props2.useContent);
    if ("update" in $$props2)
      update = $$props2.update;
    if ("canTrackToUse" in $$props2)
      canTrackToUse = $$props2.canTrackToUse;
    if ("contentState" in $$props2)
      $$invalidate(14, contentState = $$props2.contentState);
    if ("allRegisteredComponents" in $$props2)
      allRegisteredComponents = $$props2.allRegisteredComponents;
    if ("httpReqsData" in $$props2)
      httpReqsData = $$props2.httpReqsData;
    if ("clicked" in $$props2)
      clicked = $$props2.clicked;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    var _a, _b;
    if ($$self.$$.dirty[0] & /*content*/
    32) {
      $:
        onUpdateFn_0(...[content]);
    }
    if ($$self.$$.dirty[0] & /*useContent, contentState*/
    16386) {
      $:
        onUpdateFn_1(...[(_a = useContent == null ? void 0 : useContent.data) == null ? void 0 : _a.jsCode, contentState]);
    }
    if ($$self.$$.dirty[0] & /*useContent*/
    2) {
      $:
        onUpdateFn_2(...[(_b = useContent == null ? void 0 : useContent.data) == null ? void 0 : _b.httpRequests]);
    }
    if ($$self.$$.dirty[0] & /*contentState*/
    16384) {
      $:
        onUpdateFn_3(...[contentState]);
    }
  };
  return [
    model,
    useContent,
    elementRef,
    forceReRenderCount,
    onClick,
    content,
    data,
    canTrack,
    locale,
    customComponents,
    context,
    apiKey,
    includeRefs,
    apiVersion,
    contentState,
    div_binding,
    click_handler
  ];
}
var Render_content = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance19,
      create_fragment19,
      safe_not_equal,
      {
        content: 5,
        data: 6,
        canTrack: 7,
        locale: 8,
        customComponents: 9,
        model: 0,
        context: 10,
        apiKey: 11,
        includeRefs: 12,
        apiVersion: 13
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Render_content",
      options,
      id: create_fragment19.name
    });
  }
  get content() {
    throw new Error("<Render_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set content(value) {
    throw new Error("<Render_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get data() {
    throw new Error("<Render_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<Render_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get canTrack() {
    throw new Error("<Render_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set canTrack(value) {
    throw new Error("<Render_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get locale() {
    throw new Error("<Render_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set locale(value) {
    throw new Error("<Render_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get customComponents() {
    throw new Error("<Render_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set customComponents(value) {
    throw new Error("<Render_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get model() {
    throw new Error("<Render_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set model(value) {
    throw new Error("<Render_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get context() {
    throw new Error("<Render_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set context(value) {
    throw new Error("<Render_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get apiKey() {
    throw new Error("<Render_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set apiKey(value) {
    throw new Error("<Render_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get includeRefs() {
    throw new Error("<Render_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set includeRefs(value) {
    throw new Error("<Render_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get apiVersion() {
    throw new Error("<Render_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set apiVersion(value) {
    throw new Error("<Render_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var render_content_default = Render_content;

// node_modules/@builder.io/sdk-svelte/package/functions/set-editor-settings.js
var settings = {};
function setEditorSettings(newSettings) {
  if (isBrowser()) {
    Object.assign(settings, newSettings);
    const message = {
      type: "builder.settingsChange",
      data: settings
    };
    parent.postMessage(message, "*");
  }
}
export {
  button_default as Button,
  columns_default as Columns,
  fragment_default as Fragment,
  image_default as Image,
  render_blocks_default as RenderBlocks,
  render_content_default as RenderContent,
  section_default as Section,
  symbol_default as Symbol,
  text_default as Text,
  video_default as Video,
  components,
  convertSearchParamsToQueryObject,
  createRegisterComponentMessage,
  getAllContent,
  getBuilderSearchParams,
  getBuilderSearchParamsFromWindow,
  getContent,
  isEditing,
  isPreviewing,
  normalizeSearchParams,
  register,
  registerComponent,
  setEditorSettings,
  track
};
//# sourceMappingURL=@builder__io_sdk-svelte.js.map
