<script context="module" lang="ts">
  export type RenderBlockProps = {
    block: BuilderBlock;
    context: BuilderContextInterface;
  };
</script>

<script lang="ts">
  import {
    BuilderContextInterface,
    BuilderRenderState,
  } from "../../context/types.js";
  import { getBlockActions } from "../../functions/get-block-actions.js";
  import { getBlockComponentOptions } from "../../functions/get-block-component-options.js";
  import { getBlockProperties } from "../../functions/get-block-properties.js";
  import { getBlockTag } from "../../functions/get-block-tag.js";
  import { getProcessedBlock } from "../../functions/get-processed-block.js";
  import { BuilderBlock } from "../../types/builder-block.js";
  import BlockStyles from "./block-styles.svelte";
  import {
    getComponent,
    getRepeatItemData,
    isEmptyHtmlElement,
  } from "./render-block.helpers.js";
  import { RenderComponentProps } from "./render-component.svelte";
  import RenderRepeatedBlock from "./render-repeated-block.svelte";
  import { TARGET } from "../../constants/target.js";
  import { extractTextStyles } from "../../functions/extract-text-styles.js";
  import RenderComponent from "./render-component.svelte";
  import { getReactNativeBlockStyles } from "../../functions/get-react-native-block-styles.js";
  import { checkIsDefined } from "../../helpers/nullable.js";

  const setAttrs = (node, attrs = {}) => {
    const attrKeys = Object.keys(attrs);
    const setup = (attr) => node.addEventListener(attr.substr(3), attrs[attr]);
    const teardown = (attr) =>
      node.removeEventListener(attr.substr(3), attrs[attr]);
    attrKeys.map(setup);
    return {
      update(attrs = {}) {
        const attrKeys = Object.keys(attrs);
        attrKeys.map(teardown);
        attrKeys.map(setup);
      },
      destroy() {
        attrKeys.map(teardown);
      },
    };
  };

  export let block: RenderBlockProps["block"];
  export let context: RenderBlockProps["context"];

  $: tag = () => {
    return getBlockTag(useBlock());
  };
  $: useBlock = () => {
    return repeatItemData
      ? block
      : getProcessedBlock({
          block: block,
          state: context.state,
          context: context.context,
          shouldEvaluateBindings: true,
        });
  };
  $: canShowBlock = () => {
    if (checkIsDefined(useBlock().hide)) {
      return !useBlock().hide;
    }
    if (checkIsDefined(useBlock().show)) {
      return useBlock().show;
    }
    return true;
  };
  $: proxyState = () => {
    if (typeof Proxy === "undefined") {
      console.error(
        "no Proxy available in this environment, cannot proxy state."
      );
      return context.state;
    }
    const useState = new Proxy(context.state, {
      set: (obj, prop: keyof BuilderRenderState, value) => {
        // set the value on the state object, so that the event handler instantly gets the update.
        obj[prop] = value;

        // set the value in the context, so that the rest of the app gets the update.
        context.setState?.(obj);
        return true;
      },
    });
    return useState;
  };
  $: actions = () => {
    return getBlockActions({
      block: useBlock(),
      state: proxyState(),
      context: context.context,
    });
  };
  $: attributes = () => {
    const blockProperties = getBlockProperties(useBlock());
    return {
      ...blockProperties,
      ...(TARGET === "reactNative"
        ? {
            style: getReactNativeBlockStyles({
              block: useBlock(),
              context: context,
              blockStyles: blockProperties.style,
            }),
          }
        : {}),
    };
  };
  $: renderComponentProps = () => {
    return {
      blockChildren: useBlock().children ?? [],
      componentRef: component?.component,
      componentOptions: {
        ...getBlockComponentOptions(useBlock()),
        /**
         * These attributes are passed to the wrapper element when there is one. If `noWrap` is set to true, then
         * they are provided to the component itself directly.
         */
        ...(!component?.noWrap
          ? {}
          : {
              attributes: {
                ...attributes(),
                ...actions(),
              },
            }),
      },
      context: childrenContext(),
    };
  };
  $: childrenWithoutParentComponent = () => {
    /**
     * When there is no `componentRef`, there might still be children that need to be rendered. In this case,
     * we render them outside of `componentRef`.
     * NOTE: We make sure not to render this if `repeatItemData` is non-null, because that means we are rendering an array of
     * blocks, and the children will be repeated within those blocks.
     */
    const shouldRenderChildrenOutsideRef =
      !component?.component && !repeatItemData;
    return shouldRenderChildrenOutsideRef ? useBlock().children ?? [] : [];
  };
  $: childrenContext = () => {
    const getInheritedTextStyles = () => {
      if (TARGET !== "reactNative") {
        return {};
      }
      return extractTextStyles(
        getReactNativeBlockStyles({
          block: useBlock(),
          context: context,
          blockStyles: attributes().style,
        })
      );
    };
    return {
      apiKey: context.apiKey,
      apiVersion: context.apiVersion,
      state: context.state,
      content: context.content,
      context: context.context,
      setState: context.setState,
      registeredComponents: context.registeredComponents,
      inheritedStyles: getInheritedTextStyles(),
    };
  };

  let component = getComponent({
    block: block,
    context: context,
  });
  let repeatItemData = getRepeatItemData({
    block: block,
    context: context,
  });
</script>

{#if canShowBlock()}
  {#if !component?.noWrap}
    {#if isEmptyHtmlElement(tag())}
      <svelte:element this={tag()} {...attributes()} use:setAttrs={actions()} />
    {/if}

    {#if !isEmptyHtmlElement(tag()) && repeatItemData}
      {#each repeatItemData as data, index (index)}
        <RenderRepeatedBlock repeatContext={data.context} block={data.block} />
      {/each}
    {/if}

    {#if !isEmptyHtmlElement(tag()) && !repeatItemData}
      <svelte:element this={tag()} {...attributes()} use:setAttrs={actions()}>
        <RenderComponent {...renderComponentProps()} />

        {#each childrenWithoutParentComponent() as child ("render-block-" + child.id)}
          <svelte:self block={child} context={childrenContext()} />
        {/each}

        {#each childrenWithoutParentComponent() as child ("block-style-" + child.id)}
          <BlockStyles block={child} context={childrenContext()} />
        {/each}
      </svelte:element>
    {/if}
  {:else}
    <RenderComponent {...renderComponentProps()} />
  {/if}
{/if}