<script>import { onDestroy, onMount, setContext } from "svelte";
import { getDefaultRegisteredComponents } from "../../constants/builder-registered-components.js";
import "../../context/types.js";
import { evaluate } from "../../functions/evaluate.js";
import { getContent } from "../../functions/get-content/index.js";
import { fetch } from "../../functions/get-fetch.js";
import { isBrowser } from "../../functions/is-browser.js";
import { isEditing } from "../../functions/is-editing.js";
import { isPreviewing } from "../../functions/is-previewing.js";
import { components, createRegisterComponentMessage, } from "../../functions/register-component.js";
import { _track } from "../../functions/track/index.js";
import "../../types/builder-content.js";
import "../../types/typescript.js";
import RenderBlocks from "../render-blocks.svelte";
import RenderContentStyles from "./components/render-styles.svelte";
import builderContext from "../../context/builder.context.js";
import { registerInsertMenu, setupBrowserForEditing, } from "../../scripts/init-editing.js";
import { checkIsDefined } from "../../helpers/nullable.js";
import { getInteractionPropertiesForEvent } from "../../functions/track/interaction.js";
import "./render-content.types.js";
import { getContentInitialValue, getContextStateInitialValue, } from "./render-content.helpers.js";
import { TARGET } from "../../constants/target.js";
export let content;
export let data;
export let canTrack;
export let locale;
export let customComponents;
export let model;
export let context;
export let apiKey;
export let includeRefs;
export let apiVersion;
function mergeNewContent(newContent) {
    useContent = {
        ...useContent,
        ...newContent,
        data: {
            ...useContent?.data,
            ...newContent?.data,
        },
        meta: {
            ...useContent?.meta,
            ...newContent?.meta,
            breakpoints: newContent?.meta?.breakpoints || useContent?.meta?.breakpoints,
        },
    };
}
function setBreakpoints(breakpoints) {
    useContent = {
        ...useContent,
        meta: {
            ...useContent?.meta,
            breakpoints,
        },
    };
}
function setContextState(newState) {
    contentState = newState;
}
function processMessage(event) {
    const { data } = event;
    if (data) {
        switch (data.type) {
            case "builder.configureSdk": {
                const messageContent = data.data;
                const { breakpoints, contentId } = messageContent;
                if (!contentId || contentId !== useContent?.id) {
                    return;
                }
                if (breakpoints) {
                    setBreakpoints(breakpoints);
                }
                forceReRenderCount = forceReRenderCount + 1; // This is a hack to force Qwik to re-render.
                break;
            }
            case "builder.contentUpdate": {
                const messageContent = data.data;
                const key = messageContent.key ||
                    messageContent.alias ||
                    messageContent.entry ||
                    messageContent.modelName;
                const contentData = messageContent.data;
                if (key === model) {
                    mergeNewContent(contentData);
                    forceReRenderCount = forceReRenderCount + 1; // This is a hack to force Qwik to re-render.
                }
                break;
            }
            case "builder.patchUpdates": {
                // TODO
                break;
            }
        }
    }
}
function evaluateJsCode() {
    // run any dynamic JS code attached to content
    const jsCode = useContent?.data?.jsCode;
    if (jsCode) {
        evaluate({
            code: jsCode,
            context: context || {},
            state: contentState,
        });
    }
}
function onClick(event) {
    if (useContent) {
        const variationId = useContent?.testVariationId;
        const contentId = useContent?.id;
        _track({
            type: "click",
            canTrack: canTrackToUse,
            contentId,
            apiKey: apiKey,
            variationId: variationId !== contentId ? variationId : undefined,
            ...getInteractionPropertiesForEvent(event),
            unique: !clicked,
        });
    }
    if (!clicked) {
        clicked = true;
    }
}
function evalExpression(expression) {
    return expression.replace(/{{([^}]+)}}/g, (_match, group) => evaluate({
        code: group,
        context: context || {},
        state: contentState,
    }));
}
function handleRequest({ url, key }) {
    fetch(url)
        .then((response) => response.json())
        .then((json) => {
        const newState = {
            ...contentState,
            [key]: json,
        };
        setContextState(newState);
    })
        .catch((err) => {
        console.error("error fetching dynamic data", url, err);
    });
}
function runHttpRequests() {
    const requests = useContent?.data?.httpRequests ?? {};
    Object.entries(requests).forEach(([key, url]) => {
        if (url && (!httpReqsData[key] || isEditing())) {
            const evaluatedUrl = evalExpression(url);
            handleRequest({
                url: evaluatedUrl,
                key,
            });
        }
    });
}
function emitStateUpdate() {
    if (isEditing()) {
        window.dispatchEvent(new CustomEvent("builder:component:stateChange", {
            detail: {
                state: contentState,
                ref: {
                    name: model,
                },
            },
        }));
    }
}
let elementRef;
let forceReRenderCount = 0;
let overrideContent = null;
let useContent = getContentInitialValue({
    content: content,
    data: data,
});
let update = 0;
let canTrackToUse = checkIsDefined(canTrack) ? canTrack : true;
let contentState = getContextStateInitialValue({
    content: content,
    data: data,
    locale: locale,
});
let allRegisteredComponents = [
    ...getDefaultRegisteredComponents(),
    // While this `components` object is deprecated, we must maintain support for it.
    // Since users are able to override our default components, we need to make sure that we do not break such
    // existing usage.
    // This is why we spread `components` after the default Builder.io components, but before the `props.customComponents`,
    // which is the new standard way of providing custom components, and must therefore take precedence.
    ...components,
    ...(customComponents || []),
].reduce((acc, curr) => ({
    ...acc,
    [curr.name]: curr,
}), {});
let httpReqsData = {};
let clicked = false;
onMount(() => {
    if (!apiKey) {
        console.error("[Builder.io]: No API key provided to `RenderContent` component. This can cause issues. Please provide an API key using the `apiKey` prop.");
    }
    if (isBrowser()) {
        if (isEditing()) {
            forceReRenderCount = forceReRenderCount + 1;
            registerInsertMenu();
            setupBrowserForEditing({
                ...(locale
                    ? {
                        locale: locale,
                    }
                    : {}),
                ...(includeRefs
                    ? {
                        includeRefs: includeRefs,
                    }
                    : {}),
            });
            Object.values(allRegisteredComponents).forEach((registeredComponent) => {
                const message = createRegisterComponentMessage(registeredComponent);
                window.parent?.postMessage(message, "*");
            });
            window.addEventListener("message", processMessage);
            window.addEventListener("builder:component:stateChangeListenerActivated", emitStateUpdate);
        }
        if (useContent) {
            const variationId = useContent?.testVariationId;
            const contentId = useContent?.id;
            _track({
                type: "impression",
                canTrack: canTrackToUse,
                contentId,
                apiKey: apiKey,
                variationId: variationId !== contentId ? variationId : undefined,
            });
        }
        // override normal content in preview mode
        if (isPreviewing()) {
            const searchParams = new URL(location.href).searchParams;
            const searchParamPreview = searchParams.get("builder.preview");
            const previewApiKey = searchParams.get("apiKey") || searchParams.get("builder.space");
            /**
             * Make sure that:
             * - the preview model name is the same as the one we're rendering, since there can be multiple models rendered
             *  at the same time, e.g. header/page/footer.
             * - the API key is the same, since we don't want to preview content from other organizations.
             *
             * TO-DO: should we check that the preview item ID is the same as the initial one being rendered? Or would
             * this break scenarios where the item is not published yet?
             *
             * TO-DO: should we only update the state when there is a change?
             **/
            if (searchParamPreview === model && previewApiKey === apiKey) {
                getContent({
                    model: model,
                    apiKey: apiKey,
                    apiVersion: apiVersion,
                }).then((content) => {
                    if (content) {
                        mergeNewContent(content);
                    }
                });
            }
        }
        evaluateJsCode();
        runHttpRequests();
        emitStateUpdate();
    }
});
function onUpdateFn_0() {
    if (content) {
        mergeNewContent(content);
    }
}
$: onUpdateFn_0(...[content]);
function onUpdateFn_1() {
    evaluateJsCode();
}
$: onUpdateFn_1(...[useContent?.data?.jsCode, contentState]);
function onUpdateFn_2() {
    runHttpRequests();
}
$: onUpdateFn_2(...[useContent?.data?.httpRequests]);
function onUpdateFn_3() {
    emitStateUpdate();
}
$: onUpdateFn_3(...[contentState]);
setContext(builderContext.key, {
    get content() {
        return useContent;
    },
    get state() {
        return contentState;
    },
    get setState() {
        return setContextState;
    },
    get context() {
        return context || {};
    },
    get apiKey() {
        return apiKey;
    },
    get apiVersion() {
        return apiVersion;
    },
    get registeredComponents() {
        return allRegisteredComponents;
    },
});
onDestroy(() => {
    if (isBrowser()) {
        window.removeEventListener("message", processMessage);
        window.removeEventListener("builder:component:stateChangeListenerActivated", emitStateUpdate);
    }
});
</script>

{#if useContent}
  <div
    bind:this={elementRef}
    on:click={(event) => {
      onClick(event);
    }}
    builder-content-id={useContent?.id}
    builder-model={model}
  >
    {#if TARGET !== "reactNative"}
      <RenderContentStyles
        contentId={useContent?.id}
        cssCode={useContent?.data?.cssCode}
        customFonts={useContent?.data?.customFonts}
      />
    {/if}
    <RenderBlocks blocks={useContent?.data?.blocks} key={forceReRenderCount} />
  </div>
{/if}